import{_ as s,c as e,o as n,a as l}from"./app-C_Vf4vWB.js";const t="/assets/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5-BEjcmtrP.jpg",a="/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-DUJXojUl.png",p="/assets/Cookie%E3%80%81localStorage%E5%92%8CsessionStorage-FMJUxUAo.jpg",o={},r=l('<h2 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络"><span>计算机网络</span></a></h2><h3 id="_1、tcp和udp的区别" tabindex="-1"><a class="header-anchor" href="#_1、tcp和udp的区别"><span>1、TCP和UDP的区别</span></a></h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>无连接（发送数据前不需要先建立连接）</td></tr><tr><td>可靠（无差错，不丢失，不重复，且按序到达，适合大数据量的交换）</td><td>不保证可靠交付，尽最大努力交付</td></tr><tr><td>面向字节流（应用比如电子邮件、文件传送）</td><td>面向报文（不会因网络拥塞而降低发送速率，因此会出现丢包，对实时的应用比如IP电话和视频会议等）</td></tr><tr><td>首部20字节</td><td>首部8字节</td></tr><tr><td>1对1</td><td>1对1,1对多</td></tr></tbody></table><h3 id="_2、tcp拥塞机制" tabindex="-1"><a class="header-anchor" href="#_2、tcp拥塞机制"><span>2、tcp拥塞机制</span></a></h3><ul><li><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞。</p></li><li><p>∑对资源的需求&gt;可用资源</p></li><li><p>TCP进行拥塞控制的算法有四种，即<strong>慢开始、拥塞避免、快重传和快恢复</strong>。</p></li><li><p>拥塞控制也叫基于窗口的拥塞控制。发送方维持一个叫做<strong>拥塞窗口cwnd</strong>的状态变量。发送方让自己的发送窗口等于拥塞窗口。</p></li><li><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p></li><li><p><strong>判断网络拥塞的依据就是出现了超时。</strong></p></li></ul><h4 id="慢开始、拥塞避免" tabindex="-1"><a class="header-anchor" href="#慢开始、拥塞避免"><span>慢开始、拥塞避免</span></a></h4><p>发送的最初执行<strong>慢开始</strong>，<strong>令 cwnd=1，发送方只能发送 1 个报文段</strong>；当收到确认后，将 <strong>cwnd 加倍</strong>，因此之后发送方能够发送的报文段数量为：2、4、8 ...</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限ssthresh状态变量</strong>。</p><p>慢开始门限ssthresh的用法下：</p><ul><li>当cwnd&lt;ssthresh时，使用上述的慢开始算法（cwnd 加倍）。</li><li>当cwnd&gt;sthresh时，停止使用慢开始算法而改用拥塞避免算法（每个轮次只将 cwnd 加 1）。</li><li>当cwnd= ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul><p><strong>拥塞避免</strong>算法的思路是让拥塞窗口cwnd缓慢地增大，即<strong>每经过一个往返时间RTT就把发运方的拥塞窗口cwnd加1</strong>。因此在拥塞避免阶段就有”加法增大”的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><h4 id="快重传、快恢复" tabindex="-1"><a class="header-anchor" href="#快重传、快恢复"><span>快重传、快恢复</span></a></h4><p><strong>快重传</strong>算法规定，发送方只要<strong>一连收到3个重复确认</strong>，就知道接收方确实没有收到报文段M3，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</p><p>因此执行<strong>快恢复</strong>，令 <strong>ssthresh = cwnd/2 ，cwnd = ssthresh</strong>，注意到此时<strong>直接进入拥塞避免</strong>。</p><p>PS：慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p><img src="'+t+'" alt="TCP拥塞窗口cwnd在拥塞控制时的变化情况"></p><h3 id="_3、tcp三次握手" tabindex="-1"><a class="header-anchor" href="#_3、tcp三次握手"><span>3、TCP三次握手</span></a></h3><p>客户端和服务端都需要知道各自可收发，因此需要三次握手。</p><p>在TCP协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据，所以TCP也是一个全双工的协议。</p><p>1、客户端发起请求（SYN）连接服务器端。</p><p>2、服务器端接受请求，然后发送确认和请求（SYN+ACK）给客户端。</p><p>3、客户端接受请求，向服务器端发送确认连接（ACK），客户端和服务器端连接成功，完成三次握手。</p><p>简化三次握手：</p><p><img src="'+a+'" alt=""></p><p>从图片可以得到三次握手可以简化为：C发起请求连接S确认，也发起连接C确认我们再看看每次握手的作用：</p><p>第一次握手：S只可以确认：自己可以接受C发送的报文段</p><p>第二次握手：C可以确认：S收到了自己发送的报文段，并且可以确认：自己可以接受S发送的报文段</p><p>第三次握手：S可以确认：C收到了自己发送的报文段</p><p><strong>明明两次握手就可以建立起连接，为什么还需要第三次应答？</strong></p><p>为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p><h3 id="_4、-为什么连接的时候是三次握手-关闭的时候却是四次握手" tabindex="-1"><a class="header-anchor" href="#_4、-为什么连接的时候是三次握手-关闭的时候却是四次握手"><span>4、 为什么连接的时候是三次握手，关闭的时候却是四次握手？</span></a></h3><ul><li><p>因为当服务器端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。</p></li><li><p>其中ACK报文是用来应答的，SYN报文是用来同步的。</p></li><li><p>但是关闭连接时，当服务器端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，&quot;你发的FIN报文我收到了&quot;。</p></li><li><p>只有等到我服务器端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。</p></li><li><p>故需要四步握手。</p></li></ul><h3 id="_5、tcp第三次握手失败后怎么办" tabindex="-1"><a class="header-anchor" href="#_5、tcp第三次握手失败后怎么办"><span>5、TCP第三次握手失败后怎么办</span></a></h3><p>当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。</p><p>这样做的目的是为了防止SYN洪泛攻击。</p><blockquote><p>SYN攻击利用的是TCP的三次握手机制，攻击端利用伪造的IP地址向被攻击端发出请求，而被攻击端发出的响应报文将永远发送不到目的地，那么被攻击端在等待关闭这个连接的过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。我们可以利用路由器的TCP拦截功能，使网络上的主机受到保护(以Cisco路由器为例)。</p></blockquote><h3 id="_6、如果已经建立了连接-但是客户端突然出现故障了怎么办" tabindex="-1"><a class="header-anchor" href="#_6、如果已经建立了连接-但是客户端突然出现故障了怎么办"><span>6、如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></h3><ul><li>TCP设有一个保活计时器</li><li>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时</li><li>若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次</li><li>若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li></ul><h3 id="_7、进程与线程区别" tabindex="-1"><a class="header-anchor" href="#_7、进程与线程区别"><span>7、进程与线程区别</span></a></h3><p>根本区别：<strong>进程</strong>就是<strong>操作系统资源分配</strong>的基本单位，而<strong>线程</strong>是<strong>任务调度和执行</strong>的基本单位。</p><ul><li><p><strong>一个程序至少有一个进程,一个进程至少有一个线程.</strong></p></li><li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p></li><li><p>进程在执行过程中<strong>拥有独立的内存单元</strong>，而<strong>多个线程共享内存</strong>，从而极大地提高了程序的运行效率。</p></li><li><p>线程在执行过程中与进程还是有区别的。每个<strong>独立的进程</strong>有一个程序运行的入口、顺序执行序列和程序的出口。但是<strong>线程不能够独立执行</strong>，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<strong>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</strong>。这就是进程和线程的重要区别。</p></li></ul><h3 id="_8、get和post的区别" tabindex="-1"><a class="header-anchor" href="#_8、get和post的区别"><span>8、get和post的区别</span></a></h3><p><strong>副作用</strong>指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p><p><strong>幂等</strong>指发送M和N次请求（两者不相同且都大于1），服务器上的资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。</p><p>在规范的应用场景上说，Get多用于无副作用，幂等的场景，例如搜索关键字。Post多用于副作用，不幂等的场景，例如注册。</p><ul><li><p>get参数通过url传递，一般用于信息获取，post放在request body中，一般用于修改服务器上的资源。</p></li><li><p>get请求在url中传递的参数是有长度限制的，一般在2000个字符，而post没有。</p></li><li><p>get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p></li><li><p>get请求只能进行url编码，而post支持多种编码方式。</p></li><li><p>get请求会被浏览器主动cache，而post不会，除非手动设置。</p></li><li><p>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p></li><li><p>get产生一个TCP数据包；post产生两个TCP数据包。</p></li><li><p>get在浏览器回退时是无害的，而post会再次提交请求。</p></li><li><p>对参数的数据类型，get只接受ASCII字符，而post没有限制。</p></li><li><p>get和post本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p></li><li><p>get方式需要使用Request.QueryString来取得变量的值，而post方式通过Request.Form来获取变量的值，也就是说get是通过地址栏来传值，而post是通过提交表单来传值。</p></li><li><p>在以下情况中，请使用 POST 请求：</p><ul><li><p>无法使用缓存文件（更新服务器上的文件或数据库）</p></li><li><p>向服务器发送大量数据（POST 没有数据量限制）</p></li><li><p>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p></li></ul></li></ul><h3 id="_9、cookie和session的区别" tabindex="-1"><a class="header-anchor" href="#_9、cookie和session的区别"><span>9、cookie和session的区别</span></a></h3><ul><li><p>Cookie和session都可用来存储用户信息</p></li><li><p>cookie存放于客户端，session存放于服务器端</p></li><li><p>因为cookie存放于客户端有可能被窃取，所以cookie一般用来存放不敏感的信息，比如用户设置的网站主题，敏感的信息用session存储，比如用户的登陆信息，session可以存放于文件，数据库，内存中都可以</p></li><li><p>cookie可以服务器端响应的时候设置，也可以客户端通过JS设置</p></li><li><p>cookie会在请求时在http首部发送给客户端</p></li><li><p>cookie一般在客户端有大小限制，一般为4K</p></li></ul><h3 id="_10、cookie、localstorage和sessionstorage" tabindex="-1"><a class="header-anchor" href="#_10、cookie、localstorage和sessionstorage"><span>10、Cookie、localStorage和sessionStorage</span></a></h3><p>共同点：都是保存在浏览器端，并且是同源的</p><p><img src="'+p+`" alt="Cookie、localStorage和sessionStorage"></p><ul><li><p><strong>localStorage</strong>作为H5的新添特征，与cookie的区别在于：</p><p>只存储在客户端本地，而不会随http请求发送到服务器端</p><p>并且<strong>只能通过手动删除缓存来清除，不能设置失效时间</strong></p></li><li><p>如果不给cookie设置过期时间，他会在关闭浏览器的时候销毁</p></li><li><p>sessionStorage和localStorage两者虽然对存储的内容比cookie（4k左右）大得多（5M左右），但是存入的东西都被转换成了字符串，也就是说<strong>无法存入数组或者对象，就算存入了也会被转化为字符串</strong>。</p></li></ul><h4 id="手写设置cookie" tabindex="-1"><a class="header-anchor" href="#手写设置cookie"><span>手写设置cookie</span></a></h4><p><strong>1.设置cookie一天后过期</strong></p><div class="language-javascript line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="shiki dark-plus vp-code" style="background-color:#1E1E1E;color:#D4D4D4 language-javascript;"><code><span class="line"><span class="line"><span style="color:#569CD6;">function</span><span style="color:#DCDCAA;"> setCookie</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">,</span><span style="color:#9CDCFE;">expireday</span><span style="color:#D4D4D4;">){</span></span></span>
<span class="line"><span class="line"><span style="color:#569CD6;">    var</span><span style="color:#9CDCFE;"> dayobject</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">new</span><span style="color:#DCDCAA;"> Date</span><span style="color:#D4D4D4;">();  </span><span style="color:#6A9955;">// Date()函数获取当前的日期和时间</span></span></span>
<span class="line"><span class="line"><span style="color:#6A9955;">    // getTime()函数获取的事1970年1月1号至今的毫秒数</span></span></span>
<span class="line"><span class="line"><span style="color:#6A9955;">    // 注意要多加8小时，我们位于东八区比标准时间相差8小时</span></span></span>
<span class="line"><span class="line"><span style="color:#569CD6;">    var</span><span style="color:#9CDCFE;"> daynum</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">dayobject</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">getTime</span><span style="color:#D4D4D4;">() + </span><span style="color:#9CDCFE;">expireday</span><span style="color:#D4D4D4;">*(</span><span style="color:#B5CEA8;">24</span><span style="color:#D4D4D4;">+</span><span style="color:#B5CEA8;">8</span><span style="color:#D4D4D4;">)*</span><span style="color:#B5CEA8;">60</span><span style="color:#D4D4D4;">*</span><span style="color:#B5CEA8;">60</span><span style="color:#D4D4D4;">*</span><span style="color:#B5CEA8;">1000</span><span style="color:#D4D4D4;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#6A9955;">    // 计算过期时间毫秒数</span></span></span>
<span class="line"><span class="line"><span style="color:#9CDCFE;">    dayobject</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">setTime</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">daynum</span><span style="color:#D4D4D4;">);</span></span></span>
<span class="line"><span class="line"><span style="color:#6A9955;">    // 设置超时的时间</span></span></span>
<span class="line"><span class="line"><span style="color:#DCDCAA;">    alert</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;name=&#39;</span><span style="color:#D4D4D4;"> + </span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;"> + </span><span style="color:#CE9178;">&#39;;&#39;</span><span style="color:#D4D4D4;"> + </span><span style="color:#CE9178;">&#39;expires=&#39;</span><span style="color:#D4D4D4;"> + </span><span style="color:#9CDCFE;">dayobject</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">toUTCString</span><span style="color:#D4D4D4;">());</span></span></span>
<span class="line"><span class="line"><span style="color:#9CDCFE;">    document</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">cookie</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&#39;name=&#39;</span><span style="color:#D4D4D4;"> + </span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;"> + </span><span style="color:#CE9178;">&#39;;&#39;</span><span style="color:#D4D4D4;"> + </span><span style="color:#CE9178;">&#39;expires=&#39;</span><span style="color:#D4D4D4;"> + </span><span style="color:#9CDCFE;">dayobject</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">toUTCString</span><span style="color:#D4D4D4;">();</span></span></span>
<span class="line"><span class="line"><span style="color:#D4D4D4;">}</span></span></span>
<span class="line"><span class="line"><span style="color:#DCDCAA;">setCookie</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;coco&#39;</span><span style="color:#D4D4D4;">,</span><span style="color:#B5CEA8;">1</span><span style="color:#D4D4D4;">)</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2.设置cookie马上过期</strong></p><div class="language-javascript line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="shiki dark-plus vp-code" style="background-color:#1E1E1E;color:#D4D4D4 language-javascript;"><code><span class="line"><span class="line"><span style="color:#569CD6;">function</span><span style="color:#DCDCAA;"> delCookie</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">){</span></span></span>
<span class="line"><span class="line"><span style="color:#569CD6;">    var</span><span style="color:#9CDCFE;"> expires</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">new</span><span style="color:#DCDCAA;"> Date</span><span style="color:#D4D4D4;">();</span></span></span>
<span class="line"><span class="line"><span style="color:#9CDCFE;">    expires</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">setTime</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">expires</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">getTime</span><span style="color:#D4D4D4;">() - </span><span style="color:#B5CEA8;">1</span><span style="color:#D4D4D4;">);</span></span></span>
<span class="line"><span class="line"><span style="color:#9CDCFE;">    document</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">cookie</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&#39;name=&#39;</span><span style="color:#D4D4D4;">+</span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">+</span><span style="color:#CE9178;">&#39;;&#39;</span><span style="color:#D4D4D4;">+</span><span style="color:#CE9178;">&#39;expires=&#39;</span><span style="color:#D4D4D4;"> + </span><span style="color:#9CDCFE;">expires</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">toGMTString</span><span style="color:#D4D4D4;">();</span></span></span>
<span class="line"><span class="line"><span style="color:#D4D4D4;">}</span></span></span>
<span class="line"><span class="line"><span style="color:#6A9955;">// 设置cookie的过期时间是比当前时间提前一秒，也就是立马过期了。</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="设置localstorage-sessionstorage" tabindex="-1"><a class="header-anchor" href="#设置localstorage-sessionstorage"><span>设置localStorage/sessionStorage</span></a></h4><p><code>localStorage.setItem(key, value);</code></p><p><code>localStorage.getItem(key);</code></p><p><code>sessionStorage.setItem(key, value);</code></p><p><code>sessionStorage.setItem(key, value);</code></p><p>补充说明一下<strong>cookie的作用</strong>：</p><p>**保存用户登录状态。**例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个月、一年等。</p><p>**跟踪用户行为。**例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</p><h3 id="_11、强缓存和协商缓存" tabindex="-1"><a class="header-anchor" href="#_11、强缓存和协商缓存"><span>⭐11、强缓存和协商缓存</span></a></h3><p><a href="https://segmentfault.com/a/1190000008956069" target="_blank" rel="noopener noreferrer">HTTP强缓存和协商缓存</a></p><h4 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存"><span>强缓存</span></a></h4><p>在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”一般就是来源于硬盘。这也就是我们在 Chrome DevTools 上经常看到的「disk cache」。</p><p>强缓存是利用http头中的 <code>Expires</code> 和 <code>Cache-Control</code>两个字段来控制的，用来表示资源的缓存时间。</p><p>在 <code>Expires</code> 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。</p><p>而 <code>Cache-Control</code> 则可以通过给它设置一个 <code>max-age</code>，来控制过期时间。例如，<code>max-age=300</code> 就是表示在响应成功后 300 秒内，资源请求会走强缓存。</p><p>如果同时出现<code>Cache-Control:max-age</code>和<code>Expires</code>，那么<code>max-age</code>优先级更高。</p><h4 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span>协商缓存</span></a></h4><p>协商缓存通过服务器来判断缓存是否可用。协商缓存需要请求，如果缓存有效会返回304。</p><p><strong>实现协商缓存的两种方式：</strong></p><p>Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><p><strong>1、通过时间来判断是否更新</strong></p><p>服务器第一次响应时返回 <code>Last-Modified</code>，而浏览器在后续请求时带上其值作为 <code>If-Modified-Since</code>，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。</p><p><strong>2、通过标识来判断是否更新</strong></p><p>服务器第一次响应时返回 <code>ETag</code>，而浏览器在后续请求时带上其值作为 <code>If-None-Match</code>，服务器通过该值来判断是否命中缓存。</p><p><code>ETag</code>可以保证每一个资源是唯一的，资源变化都会导致<code>ETag</code>变化。</p><p>一般会用文件的 MD5 作为 <code>ETag</code>。</p><p>Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><h3 id="_12、http和https" tabindex="-1"><a class="header-anchor" href="#_12、http和https"><span>12、http和https</span></a></h3><p>(1)http和https的基本概念</p><p><a href="https://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html" target="_blank" rel="noopener noreferrer">http协议详解</a></p><p><a href="https://blog.csdn.net/qq_36183935/article/details/81156225" target="_blank" rel="noopener noreferrer">HTTP1.0、HTTP1.1、HTTP2.0的关系和区别</a></p><p>http： 超文本传输协议，是互联网上应用最为广泛的一种网络协议。</p><p>https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p><p>对称加密：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><p>非对称加密：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>(2)http和https的区别？</p><ul><li>http传输的数据都是未加密的，是明文的，连接很简单，是无状态的；而https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</li><li>端口也不同，一般而言，http协议的端口为80，https的端口为443</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul><p>(3)https协议的优点</p><ul><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li></ul><p>(4)https协议的缺点</p><ul><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ul><h3 id="_13、http状态码" tabindex="-1"><a class="header-anchor" href="#_13、http状态码"><span>13、http状态码</span></a></h3><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</p><p>200 OK 请求成功，正常返回信息</p><p>201 Created 请求成功并且服务器创建了新的资源</p><p>202 Accepted 服务器已接受请求，但尚未处理</p><p>204 No Content 请求处理成功，但没有资源可返回</p><p>206 Partial Content 对资源某一部分的请求</p><p>301 Moved Permanently 永久重定向，请求的网页已永久移动到新位置。</p><ul><li><p>比较常用的场景是使用域名跳转。</p></li><li><p>比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。</p></li><li><p>或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。</p></li><li><p>注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。</p></li></ul><p>302 Found 临时性重定向，表示资源临时被分配到了新的URL。</p><ul><li><p>比如未登陆的用户访问用户中心重定向到登录页面。</p></li><li><p>访问404页面会重新定向到首页。</p></li></ul><p>303 See Other 临时性重定向，且总是使用 GET 请求新的 URL。</p><p>304 Not Modified 自从上次请求后，请求的网页未修改过。如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。</p><p>307 Temporary Redirect 临时重定向，会遵照浏览器标准，不会从POST变成GET。</p><p>400 Bad Request 请求无效，请求报文存在语法错误。服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 请求无效</p><blockquote><p>产生原因：</p><p>前端提交数据的字段名称和字段类型与后台的实体没有保持一致</p><p>前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。</p><p>解决方法：</p><p>对照字段的名称，保持一致性</p><p>将obj对象通过JSON.stringify实现序列化</p></blockquote><p>401 Unauthorized 身份认证失败 当前请求需要用户验证 请求未授权。</p><p>403 Forbidden 服务器已经得到请求，但是拒绝执行。一般是因为传递的参数不符合后台的要求,而被拒绝访问</p><p>404 Not Found 资源请求失败</p><p>408 Request timeout 请求超时</p><p>500 Internal Server Error 服务器发生不可预知的错误</p><p>501 Not Implemented 服务未实现</p><p>502 bad gateway 网关错误</p><p>503 Service Unavailable 服务器宕机或过载</p><p>504 GatewayTime-out 网关超时</p><p>505 HTTP Version Not Supported HTTP版本不受支持</p><p><strong>总结一下</strong></p><p>1xx 临时响应，需要请求者继续执行操作</p><p>2xx 成功处理请求</p><p>3xx 重定向，需要进行附加操作以完成请求</p><p>4xx 客户端请求错误</p><p>5xx 服务器端错误</p><h3 id="_14、http支持的方法" tabindex="-1"><a class="header-anchor" href="#_14、http支持的方法"><span>14、HTTP支持的方法</span></a></h3><p>GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT</p><h3 id="_15、常见的http的头部" tabindex="-1"><a class="header-anchor" href="#_15、常见的http的头部"><span>15、常见的HTTP的头部</span></a></h3><p>可以将http首部分为通用首部，请求首部，响应首部，实体首部</p><p>通用首部表示一些通用信息，比如date表示报文创建时间</p><p>请求首部就是请求报文中独有的，如cookie，和缓存相关的如if-Modified-Since</p><p>响应首部就是响应报文中独有的，如set-cookie，和重定向相关的location</p><p>实体首部用来描述实体部分，如allow用来描述可执行的请求方法，content-type描述主题类型，content-Encoding描述主体的编码方式</p><p><strong>Request Header:</strong></p><ol><li><strong>GET /sample.Jsp HTTP/1.1</strong> //请求行</li><li><strong>Host:</strong> www.uuid.online/ //请求的目标域名和端口号</li><li><strong>Origin:</strong> http://localhost:8081/ //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li><li><strong>Referer:</strong> https:/localhost:8081/link?query=xxxxx //请求资源的完整URI</li><li><strong>User-Agent:</strong> Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 //浏览器信息</li><li><strong>Cookie:</strong> BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0 //当前域名下的Cookie</li><li><strong>Accept:</strong> text/html,image/apng //代表客户端希望接受的数据类型是html或者是png图片类型</li><li><strong>Accept-Encoding:</strong> gzip, deflate //代表客户端能支持gzip和deflate格式的压缩</li><li><strong>Accept-Language:</strong> zh-CN,zh;q=0.9 //代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)</li><li><strong>Connection:</strong> keep-alive //告诉服务器，客户端需要的tcp连接是一个长连接</li></ol><p><strong>Response Header:</strong></p><ol><li><strong>HTTP/1.1 200 OK</strong> // 响应状态行</li><li><strong>Date:</strong> Mon, 30 Jul 2018 02 : 50 : 55 GMT //服务端发送资源时的服务器时间</li><li><strong>Expires:</strong> Wed, 31 Dec 1969 23 : 59 : 59 GMT //比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li><li><strong>Cache-Control:</strong> no-cache // 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见<a href="https://www.cnblogs.com/amiezhang/p/9389537.html" target="_blank" rel="noopener noreferrer">博文”Cache-Control“</a></li><li><strong>etag:</strong> &quot;fb8ba2f80b1d324bb997cbe188f28187-ssl-df&quot; // 一般是<a href="http://www.t086.com/article/5207" target="_blank" rel="noopener noreferrer">Nginx静态服务器</a>发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”</li><li><strong>Last-Modified:</strong> Fri, 27 Jul 2018 11 : 04 : 55 GMT //是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容</li><li><strong>Content-Type:</strong> text/html; charset=utf-8 //如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</li><li><strong>Content-Encoding:</strong> gzip //告诉客户端，应该采用gzip对资源进行解码</li><li><strong>Connection:</strong> keep-alive //告诉客户端服务器的tcp连接也是一个长连接</li></ol><h3 id="_16、cookie如何防范xss攻击" tabindex="-1"><a class="header-anchor" href="#_16、cookie如何防范xss攻击"><span>16、Cookie如何防范XSS攻击</span></a></h3><p>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP的头部配上：<code>Set-Cookie=&lt;cookie-value&gt;</code></p><h3 id="_17、csrf和xss的网络攻击及防范" tabindex="-1"><a class="header-anchor" href="#_17、csrf和xss的网络攻击及防范"><span>⭐17、CSRF和XSS的网络攻击及防范</span></a></h3><p><strong>CSRF / XSRF（Cross Site Request Forgery）：跨站请求伪造。</strong></p><p><strong>攻击者盗用了用户的身份，以用户的名义发送恶意请求。</strong></p><p>比如用户登录了一个网站后，立刻在另一个tab页面访问攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库。</p><p>预防：</p><ul><li>验证 HTTP Referer 字段</li><li>在请求地址中添加 token 并验证</li><li>在 HTTP 头中自定义属性并验证</li><li>增加验证流程，如输入密码，指纹，短信验证码</li></ul><p><strong>XSS（Cross Site Scripting）：跨站脚本攻击</strong></p><p>其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有JavaScript的内容文本。这是服务器端如果没有过滤掉或转移掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p><p>大多数XSS攻击的主要方式是<strong>嵌入一段远程或者第三方域上的JS代码</strong>。<strong>攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击</strong>，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中。</p><p>预防：</p><ul><li><p>在HTTP头部配上，<code>Set-Cookie=&lt;cookie-value&gt;</code></p><ul><li>httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。</li><li>secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。</li></ul></li><li><p>转义输入输出的内容，对于引号，尖括号，斜杠进行转义。例如替换<code>&lt;</code>为<code>&amp;lt;</code>，<code>&gt;</code>为<code>&amp;gt;</code></p></li><li><p>CSP</p><ul><li><p>CSP（内容安全策略）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等。</p></li><li><p>CSP本质上是建立白名单，规定了浏览器只能够执行特定来源的代码。</p></li><li><p>通常可以通过HTTP Header中的Content-Security-Policy来开启CSP</p><p>只允许加载本站资源 <code>Content-Security-Policy: default-src &#39;self&#39;</code></p><p>只允许加载HTTPS协议图片 <code>Content-Security-Policy: img-src https://*</code></p><p>允许加载任何来源框架 <code>Content-Security-Policy: child-src &#39;none&#39;</code></p></li></ul></li></ul><h3 id="_18、url详解" tabindex="-1"><a class="header-anchor" href="#_18、url详解"><span>18、URL详解</span></a></h3><p>URL(Uniform Resource Locator) 地址用于描述一个网络上的资源，基本格式如下：</p><div class="language-javascript line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="shiki dark-plus vp-code" style="background-color:#1E1E1E;color:#D4D4D4 language-javascript;"><code><span class="line"><span class="line"><span style="color:#C8C8C8;">schema</span><span style="color:#D4D4D4;">:</span><span style="color:#6A9955;">//host[:port#]/path/.../[?query-string][#anchor]</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>schema</td><td>指定底层使用的协议(例如：http, https, ftp)</td></tr><tr><td>host</td><td>HTTP服务器的IP地址或者域名</td></tr><tr><td>port</td><td>HTTP服务器的默认端口是80，这种情况下端口号可以省略。<br>如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/</td></tr><tr><td>path</td><td>访问资源的路径</td></tr><tr><td>query-string</td><td>发送给http服务器的数据</td></tr><tr><td>anchor</td><td>锚</td></tr></tbody></table><p>URL 的一个例子</p><div class="language-javascript line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="shiki dark-plus vp-code" style="background-color:#1E1E1E;color:#D4D4D4 language-javascript;"><code><span class="line"><span class="line"><span style="color:#C8C8C8;">http</span><span style="color:#D4D4D4;">:</span><span style="color:#6A9955;">//www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#C8C8C8;">Schema</span><span style="color:#D4D4D4;">:                 </span><span style="color:#9CDCFE;">http</span></span></span>
<span class="line"><span class="line"><span style="color:#C8C8C8;">host</span><span style="color:#D4D4D4;">:                   </span><span style="color:#9CDCFE;">www</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">mywebsite</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">com</span></span></span>
<span class="line"><span class="line"><span style="color:#C8C8C8;">path</span><span style="color:#D4D4D4;">:                   /</span><span style="color:#9CDCFE;">sj</span><span style="color:#D4D4D4;">/</span><span style="color:#9CDCFE;">test</span><span style="color:#D4D4D4;">/</span><span style="color:#9CDCFE;">test</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">aspx</span></span></span>
<span class="line"><span class="line"><span style="color:#9CDCFE;">Query</span><span style="color:#C8C8C8;"> String</span><span style="color:#D4D4D4;">:           </span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">=</span><span style="color:#9CDCFE;">sviergn</span><span style="color:#D4D4D4;">&amp;</span><span style="color:#9CDCFE;">x</span><span style="color:#D4D4D4;">=</span><span style="color:#569CD6;">true</span></span></span>
<span class="line"><span class="line"><span style="color:#C8C8C8;">Anchor</span><span style="color:#D4D4D4;">:                 </span><span style="color:#9CDCFE;">stuff</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_19、dns的寻址过程-域名解析过程" tabindex="-1"><a class="header-anchor" href="#_19、dns的寻址过程-域名解析过程"><span>⭐19、DNS的寻址过程（域名解析过程）</span></a></h3><p>DNS寻址过程通常分为以下几个步骤：</p><ol><li><strong>用户输入域名</strong>： 用户在浏览器地址栏中输入一个网址，如<code>www.example.com</code>。</li><li><strong>浏览器缓存查询</strong>： 浏览器会首先检查自身缓存中是否有对应域名的IP地址。如果有缓存并且未过期，浏览器会直接使用这个IP地址进行连接。</li><li><strong>操作系统缓存查询</strong>： 如果浏览器缓存中没有找到，浏览器会向操作系统查询是否缓存有该域名的IP地址。</li><li><strong>本地DNS服务器查询</strong>： 如果操作系统也没有缓存，操作系统会向配置的本地DNS服务器（通常由ISP提供）发送请求。</li><li><strong>递归查询</strong>： 如果本地DNS服务器没有对应的缓存记录，它会以递归方式向上级DNS服务器请求。这个递归查询过程通常会经过以下几步： <ul><li><strong>根DNS服务器查询</strong>：本地DNS服务器首先查询根DNS服务器，根服务器会返回负责顶级域（如<code>.com</code>）的顶级域名服务器（TLD DNS）的地址。</li><li><strong>顶级域名服务器查询</strong>：本地DNS服务器接着向TLD DNS查询，这些服务器会返回负责该域名的权威DNS服务器的地址。</li><li><strong>权威DNS服务器查询</strong>：本地DNS服务器最终向权威DNS服务器发送请求，权威DNS服务器返回最终的IP地址。</li></ul></li><li><strong>缓存结果</strong>： 本地DNS服务器获取到IP地址后会将结果缓存，并返回给操作系统。操作系统再将结果返回给浏览器。</li><li><strong>建立连接</strong>： 浏览器获得IP地址后，通过该IP地址与目标服务器建立连接，进行数据传输。</li></ol><p>这个DNS寻址过程通常在几毫秒内完成，确保用户能够快速访问网站。</p><h3 id="_20、从输入url到得到html的详细过程" tabindex="-1"><a class="header-anchor" href="#_20、从输入url到得到html的详细过程"><span>⭐20、从输入url到得到html的详细过程</span></a></h3><h4 id="_1-输入url并解析" tabindex="-1"><a class="header-anchor" href="#_1-输入url并解析"><span>1. 输入URL并解析</span></a></h4><ul><li>用户在浏览器中输入URL，例如<code>https://www.example.com</code>。</li><li>浏览器解析URL，分解出协议（<code>https</code>）、域名（<code>www.example.com</code>）、路径（如<code>/index.html</code>）和查询参数。</li></ul><h4 id="_2-dns解析" tabindex="-1"><a class="header-anchor" href="#_2-dns解析"><span>2. DNS解析</span></a></h4><ul><li>浏览器检查本地缓存和操作系统缓存，尝试找到域名对应的IP地址。</li><li>如果没有命中缓存，浏览器会向配置的本地DNS服务器发起DNS查询。</li><li>DNS服务器通过递归查询（从根DNS服务器到顶级域名服务器再到权威DNS服务器）获取域名对应的IP地址。</li><li>获取到IP地址后，DNS服务器将其返回给浏览器。</li></ul><h4 id="_3-建立tcp连接" tabindex="-1"><a class="header-anchor" href="#_3-建立tcp连接"><span>3. 建立TCP连接</span></a></h4><ul><li>浏览器使用获取到的IP地址，通过三次握手过程与服务器建立TCP连接。 <ul><li>1、客户端发起请求（SYN）连接服务器端。</li><li>2、服务器端接受请求，然后发送确认和请求（SYN+ACK）给客户端。</li><li>3、客户端接受请求，向服务器端发送确认连接（ACK），客户端和服务器端连接成功，完成三次握手。</li></ul></li></ul><h4 id="_4-tls握手-如果使用https" tabindex="-1"><a class="header-anchor" href="#_4-tls握手-如果使用https"><span>4. TLS握手（如果使用HTTPS）</span></a></h4><p>如果使用的是<code>https</code>协议，还需要进行TLS握手来建立一个加密的通信通道。TLS握手步骤包括：</p><ol><li><strong>客户端Hello</strong>：客户端发送支持的加密算法和随机数。</li><li><strong>服务器Hello</strong>：服务器选择加密算法，返回证书和随机数。</li><li><strong>密钥生成</strong>：双方生成对称密钥并交换加密信息。</li><li><strong>握手完成</strong>：加密通信通道建立，开始传输数据。</li></ol><h4 id="_5-发送http请求" tabindex="-1"><a class="header-anchor" href="#_5-发送http请求"><span>5. 发送HTTP请求</span></a></h4><ul><li>连接建立后，浏览器发送HTTP请求给服务器。请求通常包含以下部分： <ul><li>请求行：包括请求方法（GET、POST等）、资源路径、使用的HTTP版本。</li><li>请求头：可能包括User-Agent、Accept-Language、Cookie等信息。</li><li>请求体：如果是POST请求，可能会有表单数据或其他类型的数据。</li></ul></li></ul><h4 id="_6-服务器处理请求并响应" tabindex="-1"><a class="header-anchor" href="#_6-服务器处理请求并响应"><span>6. 服务器处理请求并响应</span></a></h4><ul><li>查找请求的资源（如HTML文件、动态生成页面等）。</li><li>生成HTTP响应，通常包括状态行（如<code>HTTP/1.1 200 OK</code>）、响应头（如<code>Content-Type: text/html</code>）和响应体（即HTML内容）。</li></ul><h4 id="_7-浏览器接收响应" tabindex="-1"><a class="header-anchor" href="#_7-浏览器接收响应"><span>7. 浏览器接收响应</span></a></h4><p>浏览器接收到HTTP响应后，开始解析HTML文档。</p><h4 id="_8-html解析与渲染" tabindex="-1"><a class="header-anchor" href="#_8-html解析与渲染"><span>8.HTML解析与渲染</span></a></h4><ul><li>浏览器解析HTML内容并开始渲染页面，具体过程包括： <ol><li><strong>构建DOM树</strong>：将HTML标签解析成DOM（文档对象模型）树。</li><li><strong>构建CSSOM树</strong>：解析CSS并构建CSSOM（CSS对象模型）树。</li><li><strong>生成渲染树</strong>：结合DOM树和CSSOM树生成渲染树，用于实际显示内容。</li><li><strong>布局与绘制</strong>：计算各个元素的布局位置，并将其绘制到屏幕上。</li></ol></li></ul><h4 id="_9-处理外部资源" tabindex="-1"><a class="header-anchor" href="#_9-处理外部资源"><span>9.处理外部资源</span></a></h4><p>在HTML解析过程中，如果遇到外部资源（如CSS、JavaScript、图像等），浏览器会发送额外的HTTP请求获取这些资源，并继续解析与渲染。</p><h4 id="_10-javascript执行" tabindex="-1"><a class="header-anchor" href="#_10-javascript执行"><span>10. JavaScript执行</span></a></h4><p>当遇到 JavaScript 后会阻塞 DOM 的解析</p><p>浏览器在解析HTML时会遇到JavaScript代码或外部脚本。这些脚本会被下载并执行，可以操作DOM、修改页面内容或发起额外的网络请求（如AJAX）。</p><h4 id="_11-页面呈现" tabindex="-1"><a class="header-anchor" href="#_11-页面呈现"><span>11.页面呈现</span></a></h4><p>当所有资源加载完成后，浏览器最终完成页面的渲染，用户可以看到完整的网页内容。</p><h3 id="_21、什么是token验证" tabindex="-1"><a class="header-anchor" href="#_21、什么是token验证"><span>21、什么是token验证</span></a></h3><p>在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>下面部分转载<a href="https://www.cnblogs.com/xuxinstyle/p/9675541.html" target="_blank" rel="noopener noreferrer">深入理解token</a></p><p>可以解决哪些问题呢？</p><ol><li>Token 完全由应用管理，所以它可以避开同源策略</li><li>Token 可以避免 CSRF 攻击</li><li>Token 可以是无状态的，可以在多个服务间共享</li></ol><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。</p><h3 id="_22、http预请求options" tabindex="-1"><a class="header-anchor" href="#_22、http预请求options"><span>22、http预请求options</span></a></h3><p>转载自<a href="https://blog.csdn.net/kahhy/article/details/81563063" target="_blank" rel="noopener noreferrer">http预请求options</a></p><p>这是浏览器对复杂跨域请求的一种处理方式,在真正发送请求之前,会先进行一次预请求,就是我们刚刚说到的参数为OPTIONS的第一次请求,他的作用是用于试探性的服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问。</p><p>有三种方式会导致这种现象:</p><p>1、请求的方法不是GET/HEAD/POST</p><p>2、POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain</p><p>3、请求设置了自定义的header字段</p><h3 id="_23、表单提交和json提交" tabindex="-1"><a class="header-anchor" href="#_23、表单提交和json提交"><span>23、表单提交和json提交</span></a></h3><p>当HTTP协议中Content-Type为 <code>application/json</code> 的时候，HTTP POST请求数据必须是JSON的。</p><p>当Content-Type为 <code>x-www-form-urlencoded</code> 的时候，POST 的请求数据必须是表单的。</p><h3 id="_24、使用http-2-0" tabindex="-1"><a class="header-anchor" href="#_24、使用http-2-0"><span>24、使用HTTP/2.0</span></a></h3><p>因为浏览器会有并发请求限制，在HTTP/1.1时代，每个请求都需要建立和断开，消耗了好几个RTT时间，并且由于TCP慢启动的原因，加载体积大的文件会需要更多的时间。</p><p>在HTTP/2.0中引入了多路复用，能够让多个请求使用同一个TCP链接，极大地加快了网页的加载速度。并且还支持Header压缩，进一步的减少了请求的数据大小。</p><h3 id="_25、http请求头中referer的含义和作用" tabindex="-1"><a class="header-anchor" href="#_25、http请求头中referer的含义和作用"><span>25、http请求头中Referer的含义和作用</span></a></h3><p>转载自：<a href="https://blog.csdn.net/shenqueying/article/details/79426884" target="_blank" rel="noopener noreferrer">http请求头中Referer的含义和作用</a></p><p>Referer是 HTTP 请求 header 的一部分，当浏览器（或者模拟浏览器行为）向 web 服务器发送请求的时候，头信息里有包含 Referer。</p><p>比如我在<code>www.google.com</code> 里有一个<code>www.baidu.com</code> 链接，那么点击这个<code>www.baidu.com</code> ，它的<code>header</code> 信息里就有：Referer=http://www.google.com</p><p><strong>Referer的作用</strong></p><p>1、防盗链</p><p>我在www.google.com里有一个<code>www.baidu.com</code>链接，那么点击这个<code>www.baidu.com</code>，它的header信息里就有：</p><blockquote><p>Referer=http://www.google.com</p></blockquote><p>那么可以利用这个来防止盗链了，比如我只允许我自己的网站访问我自己的图片服务器，那我的域名是<code>www.google.com</code>，那么图片服务器每次取到Referer来判断一下是不是我自己的域名<code>www.google.com</code>，如果是就继续访问，不是就拦截。</p><p><strong>将这个http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访问。</strong></p><p>2、防止恶意请求</p><p>比如静态请求是<code>*.html</code>结尾的，动态请求是<code>*.shtml</code>，那么由此可以这么用，所有的<code>*.shtml</code>请求，必须Referer为我自己的网站。</p><p><strong>空Referer是怎么回事？什么情况下会出现Referer?</strong></p><p>首先，我们对空Referer请求中根本不包含Referer头部。</p><p>比如，直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含Referer字段的，因为这是一个“凭空产生”的HTTP请求，并不是从一个地方链接过去的。</p><h3 id="_26、同一进程中的线程究竟共享哪些资源" tabindex="-1"><a class="header-anchor" href="#_26、同一进程中的线程究竟共享哪些资源"><span>26、同一进程中的线程究竟共享哪些资源</span></a></h3><p>来源：<a href="https://blog.csdn.net/zishengzheng/article/details/81941589" target="_blank" rel="noopener noreferrer">同一进程中的线程究竟共享哪些资源</a></p><p>一般的评价标准是：如果某些资源不独享会导致线程运行错误，则该资源就由每个线程独享，而其他资源都由进程里面的所有线程共享。</p><table><thead><tr><th>线程共享资源</th><th>线程独享资源</th></tr></thead><tbody><tr><td>地址空间</td><td>程序计数器</td></tr><tr><td>全局变量</td><td>寄存器</td></tr><tr><td>打开的文件</td><td>栈</td></tr><tr><td>子进程</td><td>状态字</td></tr><tr><td>闹铃</td><td>线程ID</td></tr><tr><td>信号及信号服务程序</td><td>线程优先级</td></tr></tbody></table>`,230),i=[r];function c(d,h){return n(),e("div",null,i)}const D=s(o,[["render",c],["__file","计算机网络.html.vue"]]),u=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"计算机网络","slug":"计算机网络","link":"#计算机网络","children":[{"level":3,"title":"1、TCP和UDP的区别","slug":"_1、tcp和udp的区别","link":"#_1、tcp和udp的区别","children":[]},{"level":3,"title":"2、tcp拥塞机制","slug":"_2、tcp拥塞机制","link":"#_2、tcp拥塞机制","children":[]},{"level":3,"title":"3、TCP三次握手","slug":"_3、tcp三次握手","link":"#_3、tcp三次握手","children":[]},{"level":3,"title":"4、 为什么连接的时候是三次握手，关闭的时候却是四次握手？","slug":"_4、-为什么连接的时候是三次握手-关闭的时候却是四次握手","link":"#_4、-为什么连接的时候是三次握手-关闭的时候却是四次握手","children":[]},{"level":3,"title":"5、TCP第三次握手失败后怎么办","slug":"_5、tcp第三次握手失败后怎么办","link":"#_5、tcp第三次握手失败后怎么办","children":[]},{"level":3,"title":"6、如果已经建立了连接，但是客户端突然出现故障了怎么办？","slug":"_6、如果已经建立了连接-但是客户端突然出现故障了怎么办","link":"#_6、如果已经建立了连接-但是客户端突然出现故障了怎么办","children":[]},{"level":3,"title":"7、进程与线程区别","slug":"_7、进程与线程区别","link":"#_7、进程与线程区别","children":[]},{"level":3,"title":"8、get和post的区别","slug":"_8、get和post的区别","link":"#_8、get和post的区别","children":[]},{"level":3,"title":"9、cookie和session的区别","slug":"_9、cookie和session的区别","link":"#_9、cookie和session的区别","children":[]},{"level":3,"title":"10、Cookie、localStorage和sessionStorage","slug":"_10、cookie、localstorage和sessionstorage","link":"#_10、cookie、localstorage和sessionstorage","children":[]},{"level":3,"title":"⭐11、强缓存和协商缓存","slug":"_11、强缓存和协商缓存","link":"#_11、强缓存和协商缓存","children":[]},{"level":3,"title":"12、http和https","slug":"_12、http和https","link":"#_12、http和https","children":[]},{"level":3,"title":"13、http状态码","slug":"_13、http状态码","link":"#_13、http状态码","children":[]},{"level":3,"title":"14、HTTP支持的方法","slug":"_14、http支持的方法","link":"#_14、http支持的方法","children":[]},{"level":3,"title":"15、常见的HTTP的头部","slug":"_15、常见的http的头部","link":"#_15、常见的http的头部","children":[]},{"level":3,"title":"16、Cookie如何防范XSS攻击","slug":"_16、cookie如何防范xss攻击","link":"#_16、cookie如何防范xss攻击","children":[]},{"level":3,"title":"⭐17、CSRF和XSS的网络攻击及防范","slug":"_17、csrf和xss的网络攻击及防范","link":"#_17、csrf和xss的网络攻击及防范","children":[]},{"level":3,"title":"18、URL详解","slug":"_18、url详解","link":"#_18、url详解","children":[]},{"level":3,"title":"⭐19、DNS的寻址过程（域名解析过程）","slug":"_19、dns的寻址过程-域名解析过程","link":"#_19、dns的寻址过程-域名解析过程","children":[]},{"level":3,"title":"⭐20、从输入url到得到html的详细过程","slug":"_20、从输入url到得到html的详细过程","link":"#_20、从输入url到得到html的详细过程","children":[]},{"level":3,"title":"21、什么是token验证","slug":"_21、什么是token验证","link":"#_21、什么是token验证","children":[]},{"level":3,"title":"22、http预请求options","slug":"_22、http预请求options","link":"#_22、http预请求options","children":[]},{"level":3,"title":"23、表单提交和json提交","slug":"_23、表单提交和json提交","link":"#_23、表单提交和json提交","children":[]},{"level":3,"title":"24、使用HTTP/2.0","slug":"_24、使用http-2-0","link":"#_24、使用http-2-0","children":[]},{"level":3,"title":"25、http请求头中Referer的含义和作用","slug":"_25、http请求头中referer的含义和作用","link":"#_25、http请求头中referer的含义和作用","children":[]},{"level":3,"title":"26、同一进程中的线程究竟共享哪些资源","slug":"_26、同一进程中的线程究竟共享哪些资源","link":"#_26、同一进程中的线程究竟共享哪些资源","children":[]}]}],"git":{"updatedTime":1725294921000,"contributors":[{"name":"chenshimeng","email":"chenshimeng@hyperchain.cn","commits":1},{"name":"csmSimona","email":"980715844@qq.com","commits":1}]},"filePathRelative":"前端基础汇总/计算机网络.md","readingTime":{"minutes":33.11,"words":9933}}');export{D as comp,u as data};
