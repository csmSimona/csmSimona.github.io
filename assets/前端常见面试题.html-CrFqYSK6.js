import{_ as a,c as l,a as s,o as t}from"./app-BgzbyJvw.js";const i={};function n(r,e){return t(),l("div",null,e[0]||(e[0]=[s('<h1 id="前端常见面试题" tabindex="-1"><a class="header-anchor" href="#前端常见面试题"><span>前端常见面试题</span></a></h1><h2 id="vue常见面试题" tabindex="-1"><a class="header-anchor" href="#vue常见面试题"><span>Vue常见面试题</span></a></h2><h2 id="react常见面试题" tabindex="-1"><a class="header-anchor" href="#react常见面试题"><span>React常见面试题</span></a></h2><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h2><h3 id="什么是服务端渲染" tabindex="-1"><a class="header-anchor" href="#什么是服务端渲染"><span>什么是服务端渲染？</span></a></h3><p>服务端渲染（Server-Side Rendering，简称 SSR）是一种<strong>将网页内容在服务器端动态生成并发送给客户端的技术</strong>。传统的客户端渲染（Client-Side Rendering，简称 CSR）是在客户端浏览器中使用 JavaScript 动态生成页面内容。</p><p>在传统的客户端渲染中，浏览器首先下载一个空的 HTML 页面，然后通过 JavaScript 请求数据并生成页面内容。这种方式的优点是可以提供更丰富的交互和动态效果，但也存在一些缺点。例如，搜索引擎爬虫可能无法正确解析和索引页面内容，导致 SEO（搜索引擎优化）问题。同时，初始加载时用户可能会看到空白的页面或者出现闪烁的内容。</p><p>相比之下，服务端渲染通过在服务器上预先生成完整的 HTML 页面，将其发送给客户端浏览器。这样，浏览器在接收到页面时就能够立即显示完整的内容，而不需要等待 JavaScript 的下载和执行。这样可以提高页面的加载速度和首次渲染速度，并且对于搜索引擎爬虫来说更容易解析和索引页面内容，有利于 SEO。</p><p>客户端渲染：获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。</p><p>服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。</p><ul><li>优点：首屏渲染快，SEO 好。</li><li>缺点：配置麻烦，增加了服务器的计算压力。</li></ul><h4 id="客户端渲染过程" tabindex="-1"><a class="header-anchor" href="#客户端渲染过程"><span>客户端渲染过程</span></a></h4><ol><li>访问客户端渲染的网站。</li><li>服务器返回一个包含了引入资源语句和 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 的 HTML 文件。</li><li>客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 <code>new Vue()</code> 开始实例化并渲染页面。</li></ol><h4 id="服务端渲染过程" tabindex="-1"><a class="header-anchor" href="#服务端渲染过程"><span>服务端渲染过程</span></a></h4><ol><li>访问服务端渲染的网站。</li><li>服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。</li><li>当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 <code>new Vue()</code> 开始实例化并接管页面。</li></ol><p>从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。</p><h3 id="nuxt-js、next-js、nest-js的区别" tabindex="-1"><a class="header-anchor" href="#nuxt-js、next-js、nest-js的区别"><span>Nuxt.js、Next.js、Nest.js的区别</span></a></h3><ul><li>Nuxt.js 和 Next.js 都是用于构建服务器渲染应用的框架（SSR），分别基于 Vue.js 和 React。</li><li>Nuxt.js 适用于构建 Vue.js 应用程序，提供了默认的配置和约定，使得开发 SSR 应用更加简单。</li><li>Next.js 适用于构建 React 应用程序，具有出色的性能和开发体验，并支持静态生成和服务器端渲染。</li><li>Nest.js 是一个用于构建 Node.js 服务器端应用的框架，结合了 TypeScript 和面向对象编程的概念，提供了模块化的架构设计和丰富的功能。</li></ul><h3 id="什么是seo-怎么解决seo不友好" tabindex="-1"><a class="header-anchor" href="#什么是seo-怎么解决seo不友好"><span>什么是SEO，怎么解决SEO不友好</span></a></h3><p>seo是搜索引擎优化。在搜索引擎自然排名机制的基础上,对网站进行内部及外部的调整优化,改进网站在搜索引擎中的关键词自然排名,获得更多的流量</p><p>单页面的内容是根据路由变化动态生成并展示出来的，很多页面的内容是通过ajax异步获取的,网络抓取工具并不会等待异步请求完成后再行抓取页面内容</p><p>搜索引擎爬虫是不会等待异步请求数据结束后再抓取信息的</p><p>解决方式可以使用<code>SSR(服务端渲染)</code>或者是<code>预渲染</code></p><h3 id="vue-react-jquery的区别" tabindex="-1"><a class="header-anchor" href="#vue-react-jquery的区别"><span>Vue react jquery的区别</span></a></h3><h4 id="jquery和框架的区别" tabindex="-1"><a class="header-anchor" href="#jquery和框架的区别"><span>jquery和框架的区别</span></a></h4><p>框架：数据和视图分离，以数据驱动视图，只关心数据变化，dom操作被封装。数据驱动</p><p>jquery： 依靠dom操作去组合业务逻辑。事件驱动</p><h4 id="react和vue对比" tabindex="-1"><a class="header-anchor" href="#react和vue对比"><span>⭐React和Vue对比</span></a></h4><p>这篇文章挺好的：https://www.jianshu.com/p/b7cd52868e95?from=groupmessage</p><p><strong>两者本质区别</strong></p><ul><li>Vue—本质是MVVM框架，由MVC发展而来</li><li>React—本质是前端组件化框架，由后端组件化发展而来</li></ul><p><strong>模板的区别</strong></p><ul><li>Vue—使用模板（最初由Angular提出）</li><li>React—使用JSX</li><li>模板语法上，更倾向于JSX</li><li>模板分离上，更倾向于Vue（React模板与JS混在一起，未分离）</li></ul><p><strong>组件化的区别</strong></p><ul><li>React本身就是组件化，没有组件化就不是React</li><li>Vue也支持组件化，不过是在MVVM上的扩展</li><li>对于组件化，更倾向于React，做得彻底而清新</li></ul><p><strong>两者共同点</strong></p><ul><li>都支持组件化</li><li>都是数据驱动视图</li></ul><h4 id="什么时候用react-什么时候用vue" tabindex="-1"><a class="header-anchor" href="#什么时候用react-什么时候用vue"><span>什么时候用react，什么时候用vue</span></a></h4><p>react灵活性比较大，处理复杂业务时有更多技术方案的选择 。</p><p>vue提供了更丰富的api，实现功能简单，但也因api多会对灵活性有一定的限制。</p><p>做复杂度比较高的项目时使用react，面向用户端复杂度不高的使用vue 。</p>',41)]))}const p=a(i,[["render",n],["__file","前端常见面试题.html.vue"]]),h=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"前端常见面试题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Vue常见面试题","slug":"vue常见面试题","link":"#vue常见面试题","children":[]},{"level":2,"title":"React常见面试题","slug":"react常见面试题","link":"#react常见面试题","children":[]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[{"level":3,"title":"什么是服务端渲染？","slug":"什么是服务端渲染","link":"#什么是服务端渲染","children":[]},{"level":3,"title":"Nuxt.js、Next.js、Nest.js的区别","slug":"nuxt-js、next-js、nest-js的区别","link":"#nuxt-js、next-js、nest-js的区别","children":[]},{"level":3,"title":"什么是SEO，怎么解决SEO不友好","slug":"什么是seo-怎么解决seo不友好","link":"#什么是seo-怎么解决seo不友好","children":[]},{"level":3,"title":"Vue react jquery的区别","slug":"vue-react-jquery的区别","link":"#vue-react-jquery的区别","children":[]}]}],"git":{"updatedTime":1725470219000,"contributors":[{"name":"csmSimona","email":"980715844@qq.com","commits":2},{"name":"chenshimeng","email":"chenshimeng@hyperchain.cn","commits":1}]},"filePathRelative":"前端基础汇总/前端常见面试题.md","readingTime":{"minutes":4.7,"words":1411}}');export{p as comp,h as data};
