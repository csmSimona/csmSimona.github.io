import{_ as e,I as l,c as n,o as t,j as s,J as h,ao as r,a as p}from"./chunks/framework.DBOa8TSl.js";const m=JSON.parse('{"title":"Git小记","description":"","frontmatter":{},"headers":[],"relativePath":"其他/Git小记.md","filePath":"其他/Git小记.md","lastUpdated":1752911801000}'),d={name:"其他/Git小记.md"};function k(c,i,o,g,b,F){const a=l("ArticleMetadata");return t(),n("div",null,[i[0]||(i[0]=s("h1",{id:"git小记",tabindex:"-1"},[p("Git小记 "),s("a",{class:"header-anchor",href:"#git小记","aria-label":"Permalink to “Git小记”"},"​")],-1)),h(a),i[1]||(i[1]=r(`<h3 id="_1、查看我的分支和-master-的不同" tabindex="-1">1、查看我的分支和 master 的不同 <a class="header-anchor" href="#_1、查看我的分支和-master-的不同" aria-label="Permalink to “1、查看我的分支和 master 的不同”">​</a></h3><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> diff</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> master..my-branch</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_2、定制提交" tabindex="-1">2、定制提交 <a class="header-anchor" href="#_2、定制提交" aria-label="Permalink to “2、定制提交”">​</a></h3><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 编辑上次提交</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --amend</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;更好的提交日志&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 在上次提交中附加一些内容，保持提交日志不变</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --amend</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --no-edit</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 空提交 —— 可以用来重新触发 CI 构建</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --allow-empty</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;chore: re-trigger build&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_3、暂存区操作" tabindex="-1">3、暂存区操作 <a class="header-anchor" href="#_3、暂存区操作" aria-label="Permalink to “3、暂存区操作”">​</a></h3><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 将当前修改添加到暂存区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查看暂存区列表</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 恢复暂存区最近的记录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 恢复暂存区指定记录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash@{n}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 暂存区申请使用时，出现冲突，将冲突解决后的信息同步到暂存区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --index</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除指定暂存区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> drop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash@{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 恢复并删除最近一次暂存区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pop</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="_4、压缩合并提交" tabindex="-1">4、压缩合并提交 <a class="header-anchor" href="#_4、压缩合并提交" aria-label="Permalink to “4、压缩合并提交”">​</a></h3><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> merge</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --squash</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>将一个分支的所有提交压缩成一个单独的提交进行合并</p><p>不会产生合并提交，提交历史上只有一个新的提交</p><p><strong>使用场景：</strong></p><ul><li><strong>简化历史记录</strong>：当你希望将一个功能分支的所有工作合并为一个提交，以简化提交历史时使用<code>git merge --squash</code>。</li><li><strong>合并大量微小提交</strong>：如果一个分支上有大量的微小提交，可以使用<code>squash</code>将这些提交压缩成一个，避免提交历史过于冗长。</li></ul><h3 id="_5、git-rebase" tabindex="-1">5、git rebase <a class="header-anchor" href="#_5、git-rebase" aria-label="Permalink to “5、git rebase”">​</a></h3><p><strong>执行完git pull --rebase之后如果有合并冲突，使用以下三种方式处理这些冲突：</strong></p><ul><li><code>git rebase --abort</code> 会放弃合并，回到rebase操作之前的状态，之前的提交的不会丢弃；</li><li><code>git rebase --skip</code> 则会将引起冲突的commits丢弃掉（慎用！！）；</li><li><code>git rebase --continue</code> 合并冲突，结合&quot;git add 文件&quot;命令一起用与修复冲突，提示开发者，一步一步地有没有解决冲突。</li></ul><p><strong>功能：</strong></p><ul><li><code>git rebase</code>将一个分支的所有提交重新应用到另一个分支上，生成新的提交。</li><li>历史记录将被重写，避免创建合并提交。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>保持线性历史</strong>：当你希望保持提交历史的线性结构，避免合并提交时使用<code>git rebase</code>。</li><li><strong>整洁的提交历史</strong>：在个人开发或小团队合作中，可以使用<code>git rebase</code>保持整洁的提交历史，使日志记录更加简洁明了</li></ul><p><strong>总结：</strong></p><ul><li><code>git merge</code>适合需要保留完整历史记录的场景</li><li><code>git merge --squash</code>适合需要简化提交历史的场景</li><li><code>git rebase</code>适合需要简洁线性历史的场景</li></ul><h3 id="_6、将一个项目复制到另一个项目仓库" tabindex="-1">6、将一个项目复制到另一个项目仓库 <a class="header-anchor" href="#_6、将一个项目复制到另一个项目仓库" aria-label="Permalink to “6、将一个项目复制到另一个项目仓库”">​</a></h3><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --mirror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">老仓库的git地</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">址</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">克隆下来的项目目</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">录</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> remote</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-url</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">新的git项目的地</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">址</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --all</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 推送本地所有分支到新仓库（包括历史记录）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --tags</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 推送标签</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_7、git-reset" tabindex="-1">7、git reset <a class="header-anchor" href="#_7、git-reset" aria-label="Permalink to “7、git reset”">​</a></h3><ul><li>git reset ：回滚到某次提交。</li><li>git reset --soft：此次提交之后的修改会被退回到暂存区。</li><li>git reset --hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的</li></ul><h3 id="_8、回退到某个commit下并更新远程仓库-回滚代码" tabindex="-1">8、回退到某个commit下并更新远程仓库（回滚代码） <a class="header-anchor" href="#_8、回退到某个commit下并更新远程仓库-回滚代码" aria-label="Permalink to “8、回退到某个commit下并更新远程仓库（回滚代码）”">​</a></h3><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --hard</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD^</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         # 回退到上个版本</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --hard</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD~3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 回退到前3次提交之前，以此类推，回退到n次提交之前</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --hard</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit_id</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # 退到/进到 指定commit的sha码</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 强推到远程，更新回退后的远程仓库</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --force</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_9、修改已经提交并push后的commit注释" tabindex="-1">9、修改已经提交并push后的commit注释 <a class="header-anchor" href="#_9、修改已经提交并push后的commit注释" aria-label="Permalink to “9、修改已经提交并push后的commit注释”">​</a></h3><p>1.修改最后一次的commit注释</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>git rebase -i HEAD~1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>2.修改pick为edit</p><ul><li>回车后进入一个页面，按i进入编辑模式</li><li>将要修改的那一条的<strong>pick</strong>修改成<strong>edit</strong></li><li>按esc退出编辑模式，输入<strong>:wq</strong>保存并退出</li></ul><p>3.<code>git rebase --continue</code></p><p>4.强制提交到远程仓库</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>git push --force</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_10、cherry-pick" tabindex="-1">10、cherry-pick <a class="header-anchor" href="#_10、cherry-pick" aria-label="Permalink to “10、cherry-pick”">​</a></h3><p>将已经提交的 commit，复制出新的 commit 应用到分支里</p><ul><li><p>复制单个</p><p><code>git cherry-pick &lt;commitHash&gt;</code></p></li><li><p>复制多个</p></li></ul><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cherry-pick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 复制多个提交</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 复制一系列提交</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cherry-pick</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> A..B</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 不包含A，包含B</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cherry-pick</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> A^..B</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 包含A和B</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p>代码冲突</p><p>场景一：解决代码冲突，重新提交到暂存区（git add .），继续执行cherry-pick</p><p><code>git cherry-pick --continue</code></p><p>场景二：放弃合并，回到操作前的样子</p><p><code>git cherry-pick --abort</code></p><p>场景三：保留已经 cherry-pick 成功的 commit，并退出 cherry-pick 流程</p><p><code>git cherry-pick --quit</code></p></li></ul><h3 id="_11、git-revert" tabindex="-1">11、git revert <a class="header-anchor" href="#_11、git-revert" aria-label="Permalink to “11、git revert”">​</a></h3><p>将现有的提交还原，恢复提交的内容，并生成一条还原记录</p><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> revert</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 撤销前一次 commit</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> revert</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD^</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 撤销前前一次 commit</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> revert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">commitHas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 撤销指定的版本</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>reset和revert的区别：</p><p><code>git reset</code>如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法</p><p><code>git revert</code>如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法</p><h3 id="_12、git-merge-和-git-rebase的区别" tabindex="-1">12、git merge 和 git rebase的区别 <a class="header-anchor" href="#_12、git-merge-和-git-rebase的区别" aria-label="Permalink to “12、git merge 和 git rebase的区别”">​</a></h3><ul><li>工作原理 <ul><li><code>git merge</code>：将一个分支的更改合并到另一个分支。它会创建一个新的提交，该提交将两个分支的更改合并在一起，并且保留了每个分支上的历史记录。</li><li><code>git rebase</code>：将当前分支的提交“移动”到目标分支的顶部，而不是创建一个新的合并提交。它会将当前分支的更改应用到目标分支的提交上，然后将当前分支移动到目标分支的最新提交之后。</li></ul></li><li>提交历史 <ul><li><code>git merge</code>：保留了每个分支的提交历史，并创建了一个新的合并提交，其中包含了两个分支的更改。</li><li><code>git rebase</code>：将当前分支的提交“重播”在目标分支的提交之上，因此它会产生一个更线性的提交历史，看起来更加清晰。这种方法有助于保持项目历史的整洁性，但可能会导致变基后的提交 ID 发生变化，这可能会影响到已共享的提交。</li></ul></li><li>合并冲突处理 <ul><li><code>git merge</code>：在合并过程中，如果存在冲突，Git 会创建一个合并提交，并提示用户手动解决冲突。解决完冲突后，再提交合并结果。</li><li><code>git rebase</code>：在重新应用每个提交的过程中，如果存在冲突，Git 会在每个冲突点停止，让用户解决冲突。然后用户可以使用 <code>git rebase --continue</code> 命令继续重新应用提交，直到全部提交都被应用完毕。</li></ul></li><li>使用场景 <ul><li><code>git merge</code>：适用于合并相对较稳定的分支，如主分支或者长期存在的开发分支。它将保留每个分支的完整历史记录，并创建一个新的合并提交，记录合并时的状态。</li><li><code>git rebase</code>：通常用于将开发分支与目标分支同步，以便于保持一个清晰、线性的提交历史。这有助于避免分支合并后产生大量的合并提交，使得提交历史更易于理解和管理。</li></ul></li></ul><h3 id="_13、为指定git仓库单独配置用户名和邮箱" tabindex="-1">13、为指定Git仓库单独配置用户名和邮箱 <a class="header-anchor" href="#_13、为指定git仓库单独配置用户名和邮箱" aria-label="Permalink to “13、为指定Git仓库单独配置用户名和邮箱”">​</a></h3><div class="language-Bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 进入指定 Git 仓库</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HelloWorld</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 局部配置用户名</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> user.name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;csmSimona&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 局部配置邮箱</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> user.email</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;980715844@qq.com&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_14、git-fetch和git-pull的区别" tabindex="-1">14、git fetch和git pull的区别 <a class="header-anchor" href="#_14、git-fetch和git-pull的区别" aria-label="Permalink to “14、git fetch和git pull的区别”">​</a></h3><p><strong>git fetch</strong></p><ul><li><strong>作用</strong>：<code>git fetch</code> 用于从远程仓库下载最新的提交、分支和标签等信息，但<strong>不会自动合并这些更改到你的本地分支</strong>。</li><li><strong>使用场景</strong>：当你想要查看远程仓库中的更新内容，而不立即将它们合并到你的工作分支时，可以使用 <code>git fetch</code>。</li><li><strong>流程</strong>： fetch 后，你可以通过 <code>git log</code>、<code>git diff</code> 等命令检查哪些更改在远程分支中。</li></ul><p><strong>git pull</strong></p><ul><li><strong>作用</strong>：<strong><code>git pull</code> 是 <code>git fetch</code> 和 <code>git merge</code> 的组合</strong>，它从远程仓库下载最新的更改，并自动尝试将这些更改合并到你的当前工作分支。</li><li><strong>使用场景</strong>：当你希望立即将远程仓库中的更改应用到本地分支时，可以使用 <code>git pull</code>。</li><li><strong>风险</strong>：如果远程仓库的更改与本地更改存在冲突，<code>git pull</code> 将提示冲突并要求解决，可能需要你手动处理。</li></ul><p><strong>最佳实践建议</strong></p><ol><li><strong>优先使用 <code>git fetch</code></strong>： <ul><li>查看差异：<code>git diff main origin/main</code>（比较本地 <code>main</code> 和远程 <code>origin/main</code>）</li><li>检查日志：<code>git log origin/main</code>（查看远程 <code>main</code> 分支的提交历史）</li><li>手动合并：<code>git merge origin/main</code>（将远程变更合并到当前分支）</li><li>或变基：<code>git rebase origin/main</code>（更整洁的线性历史）</li></ul></li><li><strong>谨慎使用 <code>git pull</code></strong>： <ul><li>仅当确定需要<strong>立即合并</strong>远程变更。</li><li>确保本地没有重要的未提交修改（可使用 <code>git stash</code> 暂存）。</li><li>理解 <code>pull</code> 的默认行为（通常是 <code>fetch + merge</code>），也可配置为 <code>fetch + rebase</code>（<code>git pull --rebase</code>）。</li></ul></li><li><strong>理解 <code>pull</code> 的配置</strong>： <ul><li><code>git config pull.rebase true</code>：设置 <code>git pull</code> 默认使用 <code>rebase</code> 代替 <code>merge</code>（避免多余的合并提交）。</li></ul></li></ol><h3 id="_15、删除已合并的功能分支" tabindex="-1">15、删除已合并的功能分支 <a class="header-anchor" href="#_15、删除已合并的功能分支" aria-label="Permalink to “15、删除已合并的功能分支”">​</a></h3><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除本地分支</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feature-branch</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除远程分支</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feature-branch</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_16、如何使用-git-多人协作开发" tabindex="-1">16、如何使用 git 多人协作开发？ <a class="header-anchor" href="#_16、如何使用-git-多人协作开发" aria-label="Permalink to “16、如何使用 git 多人协作开发？”">​</a></h3><h4 id="_1-小型项目" tabindex="-1">1.小型项目 <a class="header-anchor" href="#_1-小型项目" aria-label="Permalink to “1.小型项目”">​</a></h4><p>（例如：1-3 人的小型开发团队）</p><ul><li><strong>共享仓库模型</strong> ：大家都对同一个远程仓库进行操作。</li><li>策略： <ul><li>可以直接使用 <code>master/main</code> 分支，所有成员都可以在此分支上工作，避免复杂的分支管理。</li><li>每个开发者都在本地创建自己的功能分支进行开发，完成后合并回 <code>main</code> 或 <code>master</code>。</li><li>提交时保持简洁，并且在每次 <code>push</code> 前与远程仓库同步（<code>git pull --rebase</code>）。</li></ul></li><li>具体流程： <ol><li><code>git clone</code> 克隆远程仓库。</li><li><code>git checkout -b feature-branch</code> 创建并切换到自己的功能分支。</li><li>完成功能开发后，<code>git add .</code>、<code>git commit -m &quot;Description&quot;</code> 提交本地修改。</li><li>使用 <code>git pull --rebase</code> 更新远程仓库，解决冲突。</li><li>使用 <code>git push</code> 推送到远程仓库。</li><li>其他成员拉取最新的修改，确保项目同步。</li></ol></li></ul><h4 id="_2-中型项目" tabindex="-1">2.中型项目 <a class="header-anchor" href="#_2-中型项目" aria-label="Permalink to “2.中型项目”">​</a></h4><p>（例如：3-10 人的团队）</p><ul><li><strong>基于分支的协作</strong> ：主分支用于发布，功能开发分支（feature branch）和修复分支（bugfix branch）被广泛使用。</li><li>策略： <ul><li><code>main</code> 或 <code>master</code> 作为生产分支，稳定且可以随时部署。</li><li>开发人员通过功能分支进行开发，提交合并请求（Pull Requests）前进行代码审查。</li><li>通过 <code>develop</code> 分支进行日常开发，<code>feature</code> 分支从 <code>develop</code> 分支创建，开发完成后合并回 <code>develop</code>。</li></ul></li><li>具体流程： <ol><li><code>git clone</code> 克隆远程仓库。</li><li>切换到 <code>develop</code> 分支并保持更新（<code>git pull</code>）。</li><li>创建自己的功能分支 <code>git checkout -b feature-branch</code>。</li><li>开发完成后，将功能分支推送到远程 <code>git push origin feature-branch</code>。</li><li>创建 Pull Request (PR)，请求代码审查并合并到 <code>develop</code> 分支。</li><li>定期将 <code>develop</code> 分支合并回 <code>main</code> 或 <code>master</code> 分支进行发布。</li></ol></li></ul><h4 id="_3-大型项目" tabindex="-1">3.大型项目 <a class="header-anchor" href="#_3-大型项目" aria-label="Permalink to “3.大型项目”">​</a></h4><p>（例如：10 人以上的团队）</p><ul><li><strong>Git Flow</strong> ：这是一个非常适合大团队协作的模型。通过多个分支策略进行管理，确保版本发布和功能开发的平稳过渡。</li><li>策略： <ul><li><code>ain</code> 或 <code>master</code> 用于发布稳定版本。</li><li><code>develop</code> 分支用于日常开发，所有新功能都在此基础上开发。</li><li>使用 <code>feature</code> 分支进行独立的功能开发。</li><li>使用 <code>release</code> 分支准备发布版本，包含 Bug 修复和最后的稳定性验证。</li><li><code>hotfix</code> 分支用于快速修复生产环境的 bug。</li></ul></li><li>具体流程： <ol><li><code>git clone</code> 克隆仓库，切换到 <code>develop</code> 分支。</li><li>创建并切换到新的功能分支 <code>git checkout -b feature/feature-name</code>。</li><li>在功能分支上开发，完成后推送并创建 PR 合并回 <code>develop</code> 分支。</li><li>在 <code>develop</code> 分支合并后，测试团队测试新的功能，确保没有问题。</li><li>若需发布新版本，从 <code>develop</code> 创建 <code>release</code> 分支，进行最后的 bug 修复和稳定性测试。</li><li>发布后将 <code>release</code> 分支合并到 <code>main</code> 和 <code>develop</code> 分支。</li><li>快速修复 bug 时，从 <code>main</code> 分支创建 <code>hotfix</code> 分支，修复后合并回 <code>main</code> 和 <code>develop</code>。</li></ol></li></ul><h4 id="_4-开源项目" tabindex="-1">4.开源项目 <a class="header-anchor" href="#_4-开源项目" aria-label="Permalink to “4.开源项目”">​</a></h4><ul><li><strong>Fork &amp; Pull Request 模式</strong> ：开源项目通常采用这种模式，每个贡献者通过自己的 Fork 进行开发，并通过 Pull Request 提交贡献。</li><li>策略： <ul><li>贡献者 Fork 项目仓库到自己的 GitHub（或其他平台）账户。</li><li>在 Fork 的仓库中开发新的功能或修复 bug。</li><li>完成开发后，创建 Pull Request 提交到原仓库进行审查。</li><li>项目维护者负责合并经过审查的代码，确保项目稳定。</li></ul></li><li>具体流程： <ol><li><code>git fork</code> 仓库到自己的 GitHub 账户。</li><li><code>git clone</code> 自己 Fork 后的仓库。</li><li>创建一个功能分支 <code>git checkout -b feature-name</code>。</li><li>在功能分支上进行开发，提交修改并推送到自己的 Fork 仓库。</li><li>提交 PR 请求合并到原仓库的 <code>main</code> 或 <code>develop</code> 分支。</li><li>原项目维护者审查代码，若通过则合并；如果有问题，贡献者根据反馈修改代码。</li></ol></li></ul><h4 id="_5-闭源项目" tabindex="-1">5.闭源项目 <a class="header-anchor" href="#_5-闭源项目" aria-label="Permalink to “5.闭源项目”">​</a></h4><ul><li><strong>私有仓库</strong> ：闭源项目通常使用私有仓库进行管理，团队协作模式与开源项目类似，但可能不需要开放给外部贡献者。</li><li>策略： <ul><li>仅限团队内部访问，所有成员都在相同的权限范围内操作。</li><li>使用与中型项目类似的 Git Flow 或其他基于分支的工作流。</li></ul></li><li>具体流程： <ol><li>创建私有仓库并初始化 <code>main</code> 或 <code>master</code> 分支。</li><li>开发人员从 <code>develop</code> 分支创建功能分支进行开发。</li><li>完成后提交 PR 进行代码审查。</li><li>审查通过后，合并回 <code>develop</code> 分支并准备发布。</li><li>发布前测试人员验证，发布后合并到 <code>main</code>。</li></ol></li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h4><ul><li><strong>小型项目</strong> ：共享仓库模型，简单的开发流程。</li><li><strong>中型项目</strong> ：功能分支管理，使用 <code>develop</code> 和 <code>feature</code> 分支。</li><li><strong>大型项目</strong> ：Git Flow 模式，多分支管理，发布和修复分支分开。</li><li><strong>开源项目</strong> ：Fork &amp; Pull Request 模式，社区贡献，开放和审查。</li><li><strong>闭源项目</strong> ：私有仓库，常用 Git Flow 或类似工作流，团队内部管理。</li></ul>`,75))])}const y=e(d,[["render",k]]);export{m as __pageData,y as default};
