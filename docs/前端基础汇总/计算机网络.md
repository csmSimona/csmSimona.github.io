## 计算机网络

### 1、TCP和UDP的区别

| TCP                                                          | UDP                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 面向连接                                                     | 无连接（发送数据前不需要先建立连接）                         |
| 可靠（无差错，不丢失，不重复，且按序到达，适合大数据量的交换） | 不保证可靠交付，尽最大努力交付                               |
| 面向字节流（应用比如电子邮件、文件传送）                     | 面向报文（不会因网络拥塞而降低发送速率，因此会出现丢包，对实时的应用比如IP电话和视频会议等） |
| 首部20字节                                                   | 首部8字节                                                    |
| 1对1                                                         | 1对1,1对多                                                   |

### 2、tcp拥塞机制

- 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞。   

-  ∑对资源的需求>可用资源

- TCP进行拥塞控制的算法有四种，即**慢开始、拥塞避免、快重传和快恢复**。

- 拥塞控制也叫基于窗口的拥塞控制。发送方维持一个叫做**拥塞窗口cwnd**的状态变量。发送方让自己的发送窗口等于拥塞窗口。

- 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

- **判断网络拥塞的依据就是出现了超时。**

#### 慢开始、拥塞避免

发送的最初执行**慢开始**，**令 cwnd=1，发送方只能发送 1 个报文段**；当收到确认后，将 **cwnd 加倍**，因此之后发送方能够发送的报文段数量为：2、4、8 ... 

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个**慢开始门限ssthresh状态变量**。

慢开始门限ssthresh的用法下：

- 当cwnd<ssthresh时，使用上述的慢开始算法（cwnd 加倍）。
- 当cwnd>sthresh时，停止使用慢开始算法而改用拥塞避免算法（每个轮次只将 cwnd 加 1）。
- 当cwnd= ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。

**拥塞避免**算法的思路是让拥塞窗口cwnd缓慢地增大，即**每经过一个往返时间RTT就把发运方的拥塞窗口cwnd加1**。因此在拥塞避免阶段就有”加法增大”的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

#### 快重传、快恢复

**快重传**算法规定，发送方只要**一连收到3个重复确认**，就知道接收方确实没有收到报文段M3，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。

因此执行**快恢复**，令 **ssthresh = cwnd/2 ，cwnd = ssthresh**，注意到此时**直接进入拥塞避免**。 

PS：慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![TCP拥塞窗口cwnd在拥塞控制时的变化情况](..\picture\TCP拥塞窗口cwnd在拥塞控制时的变化情况.jpg)

### 3、TCP三次握手

客户端和服务端都需要知道各自可收发，因此需要三次握手。

在TCP协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据，所以TCP也是一个全双工的协议。

1、客户端发起请求（SYN）连接服务器端。

2、服务器端接受请求，然后发送确认和请求（SYN+ACK）给客户端。

3、客户端接受请求，向服务器端发送确认连接（ACK），客户端和服务器端连接成功，完成三次握手。

简化三次握手：

![](..\picture\三次握手.png)

从图片可以得到三次握手可以简化为：C发起请求连接S确认，也发起连接C确认我们再看看每次握手的作用：

第一次握手：S只可以确认：自己可以接受C发送的报文段

第二次握手：C可以确认：S收到了自己发送的报文段，并且可以确认：自己可以接受S发送的报文段

第三次握手：S可以确认：C收到了自己发送的报文段

**明明两次握手就可以建立起连接，为什么还需要第三次应答？**

为了防止失效的连接请求报文段被服务端接收，从而产生错误。

### 4、 为什么连接的时候是三次握手，关闭的时候却是四次握手？

- 因为当服务器端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。

- 其中ACK报文是用来应答的，SYN报文是用来同步的。

- 但是关闭连接时，当服务器端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。

- 只有等到我服务器端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。

- 故需要四步握手。

### 5、TCP第三次握手失败后怎么办

当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。

这样做的目的是为了防止SYN洪泛攻击。

> SYN攻击利用的是TCP的三次握手机制，攻击端利用伪造的IP地址向被攻击端发出请求，而被攻击端发出的响应报文将永远发送不到目的地，那么被攻击端在等待关闭这个连接的过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。我们可以利用路由器的TCP拦截功能，使网络上的主机受到保护(以Cisco路由器为例)。

### 6、如果已经建立了连接，但是客户端突然出现故障了怎么办？

- TCP设有一个保活计时器
- 服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时
- 若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次
- 若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。  

### 7、进程与线程区别

根本区别：**进程**就是**操作系统资源分配**的基本单位，而**线程**是**任务调度和执行**的基本单位。

- **一个程序至少有一个进程,一个进程至少有一个线程.**

- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 进程在执行过程中**拥有独立的内存单元**，而**多个线程共享内存**，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个**独立的进程**有一个程序运行的入口、顺序执行序列和程序的出口。但是**线程不能够独立执行**，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。**但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配**。这就是进程和线程的重要区别。

### 8、get和post的区别

**副作用**指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。

**幂等**指发送M和N次请求（两者不相同且都大于1），服务器上的资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。

在规范的应用场景上说，Get多用于无副作用，幂等的场景，例如搜索关键字。Post多用于副作用，不幂等的场景，例如注册。

- get参数通过url传递，一般用于信息获取，post放在request body中，一般用于修改服务器上的资源。


- get请求在url中传递的参数是有长度限制的，一般在2000个字符，而post没有。


- get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。


- get请求只能进行url编码，而post支持多种编码方式。


- get请求会被浏览器主动cache，而post不会，除非手动设置。 


- get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。


- get产生一个TCP数据包；post产生两个TCP数据包。

- get在浏览器回退时是无害的，而post会再次提交请求。 

- 对参数的数据类型，get只接受ASCII字符，而post没有限制。 

- get和post本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

- get方式需要使用Request.QueryString来取得变量的值，而post方式通过Request.Form来获取变量的值，也就是说get是通过地址栏来传值，而post是通过提交表单来传值。

- 在以下情况中，请使用 POST 请求：

  - 无法使用缓存文件（更新服务器上的文件或数据库）

  - 向服务器发送大量数据（POST 没有数据量限制）

  - 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

### 9、cookie和session的区别

- Cookie和session都可用来存储用户信息

- cookie存放于客户端，session存放于服务器端

- 因为cookie存放于客户端有可能被窃取，所以cookie一般用来存放不敏感的信息，比如用户设置的网站主题，敏感的信息用session存储，比如用户的登陆信息，session可以存放于文件，数据库，内存中都可以

- cookie可以服务器端响应的时候设置，也可以客户端通过JS设置

- cookie会在请求时在http首部发送给客户端

- cookie一般在客户端有大小限制，一般为4K

### 10、Cookie、localStorage和sessionStorage

共同点：都是保存在浏览器端，并且是同源的

![Cookie、localStorage和sessionStorage](..\picture\Cookie、localStorage和sessionStorage.jpg)

- **localStorage**作为H5的新添特征，与cookie的区别在于：

  只存储在客户端本地，而不会随http请求发送到服务器端

  并且**只能通过手动删除缓存来清除，不能设置失效时间**

- 如果不给cookie设置过期时间，他会在关闭浏览器的时候销毁


- sessionStorage和localStorage两者虽然对存储的内容比cookie（4k左右）大得多（5M左右），但是存入的东西都被转换成了字符串，也就是说**无法存入数组或者对象，就算存入了也会被转化为字符串**。


#### 手写设置cookie

**1.设置cookie一天后过期**

```js
function setCookie(name,expireday){
    var dayobject = new Date();  // Date()函数获取当前的日期和时间
    // getTime()函数获取的事1970年1月1号至今的毫秒数
    // 注意要多加8小时，我们位于东八区比标准时间相差8小时
    var daynum = dayobject.getTime() + expireday*(24+8)*60*60*1000;
    // 计算过期时间毫秒数
    dayobject.setTime(daynum);
    // 设置超时的时间
    alert('name=' + name + ';' + 'expires=' + dayobject.toUTCString());
    document.cookie = 'name=' + name + ';' + 'expires=' + dayobject.toUTCString();
}
setCookie('coco',1)
```

**2.设置cookie马上过期**

```js
function delCookie(name){
    var expires = new Date();
    expires.setTime(expires.getTime() - 1);
    document.cookie = 'name='+name+';'+'expires=' + expires.toGMTString();
}
// 设置cookie的过期时间是比当前时间提前一秒，也就是立马过期了。
```

#### 设置localStorage/sessionStorage

`localStorage.setItem(key, value);`

`localStorage.getItem(key);`

`sessionStorage.setItem(key, value);`

`sessionStorage.setItem(key, value);`

补充说明一下**cookie的作用**：

**保存用户登录状态。**例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个月、一年等。

**跟踪用户行为。**例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。

### :star:11、强缓存和协商缓存

[HTTP强缓存和协商缓存](https://segmentfault.com/a/1190000008956069)

#### 强缓存

在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”一般就是来源于硬盘。这也就是我们在 Chrome DevTools 上经常看到的「disk cache」。

强缓存是利用http头中的 `Expires` 和 `Cache-Control`两个字段来控制的，用来表示资源的缓存时间。

在 `Expires` 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。

而 `Cache-Control` 则可以通过给它设置一个 `max-age`，来控制过期时间。例如，`max-age=300` 就是表示在响应成功后 300 秒内，资源请求会走强缓存。

如果同时出现`Cache-Control:max-age`和`Expires`，那么`max-age`优先级更高。

#### 协商缓存

协商缓存通过服务器来判断缓存是否可用。协商缓存需要请求，如果缓存有效会返回304。

**实现协商缓存的两种方式：**

Last-Modified与ETag是可以一起使用的，**服务器会优先验证ETag**，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

**1、通过时间来判断是否更新**

服务器第一次响应时返回 `Last-Modified`，而浏览器在后续请求时带上其值作为 `If-Modified-Since`，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。

**2、通过标识来判断是否更新**

服务器第一次响应时返回 `ETag`，而浏览器在后续请求时带上其值作为 `If-None-Match`，服务器通过该值来判断是否命中缓存。

`ETag`可以保证每一个资源是唯一的，资源变化都会导致`ETag`变化。

一般会用文件的 MD5 作为 `ETag`。

Last-Modified与ETag是可以一起使用的，**服务器会优先验证ETag**，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。



### 12、http和https

(1)http和https的基本概念

[http协议详解](https://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html)

[HTTP1.0、HTTP1.1、HTTP2.0的关系和区别](https://blog.csdn.net/qq_36183935/article/details/81156225)

http： 超文本传输协议，是互联网上应用最为广泛的一种网络协议。

https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

对称加密：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。

非对称加密：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

(2)http和https的区别？

- http传输的数据都是未加密的，是明文的，连接很简单，是无状态的；而https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。
- 端口也不同，一般而言，http协议的端口为80，https的端口为443
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

(3)https协议的优点

- 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
- HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

(4)https协议的缺点

- https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。
- https缓存不如http高效，会增加数据开销。
- SSL证书也需要钱，功能越强大的证书费用越高。
- SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。

### 13、http状态码

100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息

200  OK   请求成功，正常返回信息

201  Created  请求成功并且服务器创建了新的资源

202  Accepted  服务器已接受请求，但尚未处理

204 No Content 请求处理成功，但没有资源可返回

206 Partial Content 对资源某一部分的请求

301  Moved Permanently  永久重定向，请求的网页已永久移动到新位置。

- 比较常用的场景是使用域名跳转。

- 比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 

- 或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。
- 注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。

302  Found  临时性重定向，表示资源临时被分配到了新的URL。

- 比如未登陆的用户访问用户中心重定向到登录页面。

- 访问404页面会重新定向到首页。 

303  See Other  临时性重定向，且总是使用 GET 请求新的 URL。

304  Not Modified  自从上次请求后，请求的网页未修改过。如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。

307 Temporary Redirect 临时重定向，会遵照浏览器标准，不会从POST变成GET。

400  Bad Request  请求无效，请求报文存在语法错误。服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。  请求无效

> 产生原因：
>
> 前端提交数据的字段名称和字段类型与后台的实体没有保持一致
>
> 前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。
>
> 解决方法：
>
> 对照字段的名称，保持一致性
>
> 将obj对象通过JSON.stringify实现序列化

401  Unauthorized  身份认证失败 当前请求需要用户验证 请求未授权。

403  Forbidden  服务器已经得到请求，但是拒绝执行。一般是因为传递的参数不符合后台的要求,而被拒绝访问

404  Not Found  资源请求失败

408 Request timeout 请求超时

500 Internal Server Error  服务器发生不可预知的错误

501 Not Implemented 服务未实现

502 bad gateway 网关错误

503 Service Unavailable 服务器宕机或过载

504 GatewayTime-out 网关超时

505 HTTP Version Not Supported HTTP版本不受支持

**总结一下**

1xx  临时响应，需要请求者继续执行操作

2xx  成功处理请求

3xx  重定向，需要进行附加操作以完成请求

4xx  客户端请求错误

5xx  服务器端错误

### 14、HTTP支持的方法

GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT

### 15、常见的HTTP的头部

可以将http首部分为通用首部，请求首部，响应首部，实体首部

通用首部表示一些通用信息，比如date表示报文创建时间

请求首部就是请求报文中独有的，如cookie，和缓存相关的如if-Modified-Since

响应首部就是响应报文中独有的，如set-cookie，和重定向相关的location

实体首部用来描述实体部分，如allow用来描述可执行的请求方法，content-type描述主题类型，content-Encoding描述主体的编码方式

**Request Header:**

1. **GET /sample.Jsp HTTP/1.1**  //请求行
2. **Host:** www.uuid.online/  //请求的目标域名和端口号
3. **Origin:** http://localhost:8081/  //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）
4. **Referer:** https:/localhost:8081/link?query=xxxxx  //请求资源的完整URI
5. **User-Agent:** Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 //浏览器信息
6. **Cookie:** BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0  //当前域名下的Cookie
7. **Accept:** text/html,image/apng  //代表客户端希望接受的数据类型是html或者是png图片类型 
8. **Accept-Encoding:** gzip, deflate  //代表客户端能支持gzip和deflate格式的压缩
9. **Accept-Language:** zh-CN,zh;q=0.9  //代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)
10. **Connection:** keep-alive  //告诉服务器，客户端需要的tcp连接是一个长连接

**Response Header:**

1. **HTTP/1.1 200 OK**  // 响应状态行
2. **Date:** Mon, 30 Jul 2018 02 : 50 : 55 GMT  //服务端发送资源时的服务器时间
3. **Expires:** Wed, 31 Dec 1969 23 : 59 : 59 GMT //比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页
4. **Cache-Control:**  no-cache  // 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见[博文”Cache-Control“](https://www.cnblogs.com/amiezhang/p/9389537.html)
5. **etag:** "fb8ba2f80b1d324bb997cbe188f28187-ssl-df"  // 一般是[Nginx静态服务器](http://www.t086.com/article/5207)发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”
6. **Last-Modified:** Fri, 27 Jul 2018 11 : 04 : 55 GMT //是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容
7. **Content-Type:** text/html; charset=utf-8  //如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码
8. **Content-Encoding:** gzip  //告诉客户端，应该采用gzip对资源进行解码
9. **Connection:** keep-alive  //告诉客户端服务器的tcp连接也是一个长连接

### 16、Cookie如何防范XSS攻击

XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP的头部配上：`Set-Cookie=<cookie-value>`

### :star:17、CSRF和XSS的网络攻击及防范

**CSRF / XSRF（Cross Site Request Forgery）：跨站请求伪造。**

**攻击者盗用了用户的身份，以用户的名义发送恶意请求。**

比如用户登录了一个网站后，立刻在另一个tab页面访问攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库。

预防： 

- 验证 HTTP Referer 字段
- 在请求地址中添加 token 并验证
- 在 HTTP 头中自定义属性并验证
- 增加验证流程，如输入密码，指纹，短信验证码

**XSS（Cross Site Scripting）：跨站脚本攻击**

其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有JavaScript的内容文本。这是服务器端如果没有过滤掉或转移掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。

大多数XSS攻击的主要方式是**嵌入一段远程或者第三方域上的JS代码**。**攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击**，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中。

预防： 

- 在HTTP头部配上，`Set-Cookie=<cookie-value>`
  - httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。
  - secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。

- 转义输入输出的内容，对于引号，尖括号，斜杠进行转义。例如替换`<`为`&lt;`，`>`为`&gt;`

- CSP

  - CSP（内容安全策略）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等。

  - CSP本质上是建立白名单，规定了浏览器只能够执行特定来源的代码。

  - 通常可以通过HTTP Header中的Content-Security-Policy来开启CSP

    只允许加载本站资源  `Content-Security-Policy: default-src 'self'`

    只允许加载HTTPS协议图片  `Content-Security-Policy: img-src https://*`

    允许加载任何来源框架  `Content-Security-Policy: child-src 'none'`

### 18、URL详解

URL(Uniform Resource Locator) 地址用于描述一个网络上的资源，基本格式如下：

```js
schema://host[:port#]/path/.../[?query-string][#anchor]
```

| 名称         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| schema       | 指定底层使用的协议(例如：http, https, ftp)                   |
| host         | HTTP服务器的IP地址或者域名                                   |
| port         | HTTP服务器的默认端口是80，这种情况下端口号可以省略。<br />如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/ |
| path         | 访问资源的路径                                               |
| query-string | 发送给http服务器的数据                                       |
| anchor       | 锚                                                           |

URL 的一个例子

```js
http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&x=true#stuff

Schema:                 http
host:                   www.mywebsite.com
path:                   /sj/test/test.aspx
Query String:           name=sviergn&x=true
Anchor:                 stuff
```

### :star:19、DNS的寻址过程（域名解析过程）

DNS寻址过程通常分为以下几个步骤：

1. **用户输入域名**： 用户在浏览器地址栏中输入一个网址，如`www.example.com`。
2. **浏览器缓存查询**： 浏览器会首先检查自身缓存中是否有对应域名的IP地址。如果有缓存并且未过期，浏览器会直接使用这个IP地址进行连接。
3. **操作系统缓存查询**： 如果浏览器缓存中没有找到，浏览器会向操作系统查询是否缓存有该域名的IP地址。
4. **本地DNS服务器查询**： 如果操作系统也没有缓存，操作系统会向配置的本地DNS服务器（通常由ISP提供）发送请求。
5. **递归查询**： 如果本地DNS服务器没有对应的缓存记录，它会以递归方式向上级DNS服务器请求。这个递归查询过程通常会经过以下几步：
   - **根DNS服务器查询**：本地DNS服务器首先查询根DNS服务器，根服务器会返回负责顶级域（如`.com`）的顶级域名服务器（TLD DNS）的地址。
   - **顶级域名服务器查询**：本地DNS服务器接着向TLD DNS查询，这些服务器会返回负责该域名的权威DNS服务器的地址。
   - **权威DNS服务器查询**：本地DNS服务器最终向权威DNS服务器发送请求，权威DNS服务器返回最终的IP地址。
6. **缓存结果**： 本地DNS服务器获取到IP地址后会将结果缓存，并返回给操作系统。操作系统再将结果返回给浏览器。
7. **建立连接**： 浏览器获得IP地址后，通过该IP地址与目标服务器建立连接，进行数据传输。

这个DNS寻址过程通常在几毫秒内完成，确保用户能够快速访问网站。



### :star:20、从输入url到得到html的详细过程

#### 1. 输入URL并解析

- 用户在浏览器中输入URL，例如`https://www.example.com`。
- 浏览器解析URL，分解出协议（`https`）、域名（`www.example.com`）、路径（如`/index.html`）和查询参数。

#### 2. DNS解析

- 浏览器检查本地缓存和操作系统缓存，尝试找到域名对应的IP地址。
- 如果没有命中缓存，浏览器会向配置的本地DNS服务器发起DNS查询。
- DNS服务器通过递归查询（从根DNS服务器到顶级域名服务器再到权威DNS服务器）获取域名对应的IP地址。
- 获取到IP地址后，DNS服务器将其返回给浏览器。

#### 3. 建立TCP连接

- 浏览器使用获取到的IP地址，通过三次握手过程与服务器建立TCP连接。
  - 1、客户端发起请求（SYN）连接服务器端。
  - 2、服务器端接受请求，然后发送确认和请求（SYN+ACK）给客户端。
  - 3、客户端接受请求，向服务器端发送确认连接（ACK），客户端和服务器端连接成功，完成三次握手。

#### 4. TLS握手（如果使用HTTPS）

如果使用的是`https`协议，还需要进行TLS握手来建立一个加密的通信通道。TLS握手步骤包括：

1. **客户端Hello**：客户端发送支持的加密算法和随机数。
2. **服务器Hello**：服务器选择加密算法，返回证书和随机数。
3. **密钥生成**：双方生成对称密钥并交换加密信息。
4. **握手完成**：加密通信通道建立，开始传输数据。

#### 5. 发送HTTP请求

- 连接建立后，浏览器发送HTTP请求给服务器。请求通常包含以下部分：
  - 请求行：包括请求方法（GET、POST等）、资源路径、使用的HTTP版本。
  - 请求头：可能包括User-Agent、Accept-Language、Cookie等信息。
  - 请求体：如果是POST请求，可能会有表单数据或其他类型的数据。

#### 6. 服务器处理请求并响应

- 查找请求的资源（如HTML文件、动态生成页面等）。
- 生成HTTP响应，通常包括状态行（如`HTTP/1.1 200 OK`）、响应头（如`Content-Type: text/html`）和响应体（即HTML内容）。

#### 7. 浏览器接收响应

浏览器接收到HTTP响应后，开始解析HTML文档。

#### 8.HTML解析与渲染

- 浏览器解析HTML内容并开始渲染页面，具体过程包括：
  1. **构建DOM树**：将HTML标签解析成DOM（文档对象模型）树。
  2. **构建CSSOM树**：解析CSS并构建CSSOM（CSS对象模型）树。
  3. **生成渲染树**：结合DOM树和CSSOM树生成渲染树，用于实际显示内容。
  4. **布局与绘制**：计算各个元素的布局位置，并将其绘制到屏幕上。

#### 9.处理外部资源

在HTML解析过程中，如果遇到外部资源（如CSS、JavaScript、图像等），浏览器会发送额外的HTTP请求获取这些资源，并继续解析与渲染。

#### 10. JavaScript执行

当遇到 JavaScript 后会阻塞 DOM 的解析

浏览器在解析HTML时会遇到JavaScript代码或外部脚本。这些脚本会被下载并执行，可以操作DOM、修改页面内容或发起额外的网络请求（如AJAX）。

#### 11.页面呈现

当所有资源加载完成后，浏览器最终完成页面的渲染，用户可以看到完整的网页内容。



### 21、什么是token验证

在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

下面部分转载[深入理解token](https://www.cnblogs.com/xuxinstyle/p/9675541.html)

可以解决哪些问题呢？

1. Token 完全由应用管理，所以它可以避开同源策略
2. Token 可以避免 CSRF 攻击
3. Token 可以是无状态的，可以在多个服务间共享

Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。

### 22、http预请求options

转载自[http预请求options](https://blog.csdn.net/kahhy/article/details/81563063)

这是浏览器对复杂跨域请求的一种处理方式,在真正发送请求之前,会先进行一次预请求,就是我们刚刚说到的参数为OPTIONS的第一次请求,他的作用是用于试探性的服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问。

 有三种方式会导致这种现象:

1、请求的方法不是GET/HEAD/POST

2、POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain

3、请求设置了自定义的header字段

### 23、表单提交和json提交

当HTTP协议中Content-Type为 `application/json` 的时候，HTTP POST请求数据必须是JSON的。

当Content-Type为 `x-www-form-urlencoded` 的时候，POST 的请求数据必须是表单的。

### 24、使用HTTP/2.0

因为浏览器会有并发请求限制，在HTTP/1.1时代，每个请求都需要建立和断开，消耗了好几个RTT时间，并且由于TCP慢启动的原因，加载体积大的文件会需要更多的时间。

在HTTP/2.0中引入了多路复用，能够让多个请求使用同一个TCP链接，极大地加快了网页的加载速度。并且还支持Header压缩，进一步的减少了请求的数据大小。

### 25、http请求头中Referer的含义和作用

转载自：[http请求头中Referer的含义和作用](https://blog.csdn.net/shenqueying/article/details/79426884)

Referer是 HTTP 请求 header 的一部分，当浏览器（或者模拟浏览器行为）向 web  服务器发送请求的时候，头信息里有包含 Referer。

比如我在`www.google.com` 里有一个`www.baidu.com` 链接，那么点击这个`www.baidu.com` ，它的`header` 信息里就有：Referer=http://www.google.com

**Referer的作用**

1、防盗链

我在www.google.com里有一个`www.baidu.com`链接，那么点击这个`www.baidu.com`，它的header信息里就有：

> Referer=http://www.google.com

那么可以利用这个来防止盗链了，比如我只允许我自己的网站访问我自己的图片服务器，那我的域名是`www.google.com`，那么图片服务器每次取到Referer来判断一下是不是我自己的域名`www.google.com`，如果是就继续访问，不是就拦截。

**将这个http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访问。**

2、防止恶意请求

比如静态请求是`*.html`结尾的，动态请求是`*.shtml`，那么由此可以这么用，所有的`*.shtml`请求，必须Referer为我自己的网站。

**空Referer是怎么回事？什么情况下会出现Referer?**

首先，我们对空Referer请求中根本不包含Referer头部。

比如，直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含Referer字段的，因为这是一个“凭空产生”的HTTP请求，并不是从一个地方链接过去的。

### 26、同一进程中的线程究竟共享哪些资源

来源：[同一进程中的线程究竟共享哪些资源](https://blog.csdn.net/zishengzheng/article/details/81941589)

 一般的评价标准是：如果某些资源不独享会导致线程运行错误，则该资源就由每个线程独享，而其他资源都由进程里面的所有线程共享。 

| 线程共享资源       | 线程独享资源 |
| ------------------ | ------------ |
| 地址空间           | 程序计数器   |
| 全局变量           | 寄存器       |
| 打开的文件         | 栈           |
| 子进程             | 状态字       |
| 闹铃               | 线程ID       |
| 信号及信号服务程序 | 线程优先级   |