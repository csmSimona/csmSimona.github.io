# 前端常见面试题

## Vue常见面试题



## React常见面试题

### React和Vue的区别:star:

- 都支持组件化
- 都是数据驱动视图
- 都使用vdom操作DOM

- React使用JSX拥抱JS，Vue使用模板拥抱html

- React函数式编程，Vue声明式编程
- React需要更多的自力更生，Vue把想要的都给你



### Vue react jquery的区别

#### jquery和框架的区别

 框架：数据和视图分离，以数据驱动视图，只关心数据变化，dom操作被封装。数据驱动

 jquery： 依靠dom操作去组合业务逻辑。事件驱动

#### React和Vue对比:star:

这篇文章挺好的：https://www.jianshu.com/p/b7cd52868e95?from=groupmessage

**两者本质区别**

- Vue—本质是MVVM框架，由MVC发展而来
- React—本质是前端组件化框架，由后端组件化发展而来

**模板的区别**

- Vue—使用模板（最初由Angular提出）
- React—使用JSX
- 模板语法上，更倾向于JSX
- 模板分离上，更倾向于Vue（React模板与JS混在一起，未分离）

**组件化的区别**

- React本身就是组件化，没有组件化就不是React
- Vue也支持组件化，不过是在MVVM上的扩展
- 对于组件化，更倾向于React，做得彻底而清新

**两者共同点**

- 都支持组件化
- 都是数据驱动视图



#### 什么时候用react，什么时候用vue

react灵活性比较大，处理复杂业务时有更多技术方案的选择 。

vue提供了更丰富的api，实现功能简单，但也因api多会对灵活性有一定的限制。

做复杂度比较高的项目时使用react，面向用户端复杂度不高的使用vue 。







## 前端工程化面试问题

### less在webpack中时如何被打包的

less-loader -> css-loader -> style-loader

- less-loader：用于将less翻译成浏览器可识别的css
- css-loader：处理 import / require（） @import / url 引入的内容
- style-loader：通过一个JS脚本创建一个style标签，里面包含一些样式



### ES6 Module和Common.js 的区别

- ES6 Module静态引入，编译时引入
- commonjs动态引入，执行时引入
- 只有在ES6 Module才能静态分析，实现tree-shaking

```js
// ES6 Module.js
import apiList from '../config/api.js'
if (isDev) {
    // 编译时报错，只能静态引入
    import apiList from '../config/api_dev.js'
}

// common.js
let apiList = require('../config/api.js')
if (isDev) {
    // 可以动态引入，执行时引入
    apiList = require('../config/api_dev.js')
}
```



- CommonJS 模块加载过程是同步阻塞性地加载，在模块代码被运行前就已经写入了 cache，同一个模块被多次 require 时只会执行一次，重复的 require 得到的是相同的 exports 引用。

- ES6 模块会在程序开始前先根据模块关系查找到所有模块，生成一个无环关系图，并将所有模块实例都创建好，这种方式天然地避免了循环引用的问题，当然也有模块加载缓存，重复 import 同一个模块，只会执行一次代码。

- CommonJS 可以在运行时使用变量进行 require, 例如 require(path.join('xxxx', 'xxx.js'))，而静态 import 语法（还有动态 import，返回 Promise）不行，因为 ES6 模块会先解析所有模块再执行代码。

- require 会将完整的 exports 对象引入，import 可以只 import 部分必要的内容，这也是为什么使用 Tree Shaking 时必须使用 ES6 模块 的写法。

- import 另一个模块没有 export 的变量，在代码执行前就会报错，而 CommonJS 是在模块运行时才报错。



## 项目相关

### 多页签中的右键选中，是如何做到把浏览器原生右键打开的弹窗覆盖掉的？

**自定义右键菜单具体实现**

1、禁用浏览器弹出默认菜单的行为，通过阻止[contextMenu](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/contextmenu_event)事件的默认行为，并同时触发自定义菜单的显示

2、通过Dropdown实现菜单样式，触发器`trigger`配置`contextMenu`，从而实现鼠标右键触发下拉菜单

```React
const setTab = useMemoizedFn((tab, key, index) => (
  <span onContextMenu={(event) => event.preventDefault()}>
      <Dropdown overlay={setMenu(key, index)} trigger={['contextMenu']}>
        <span className={styles.tabTitle}>{tab}</span>
      </Dropdown>
  </span>
));
```



### 竞态问题（TODO）

AbortController

https://juejin.cn/post/6970710521104302110

竞态问题（Race Condition）是指在并发编程中，当多个操作顺序不确定时，可能导致意外的结果。在前端开发中，竞态问题通常出现在异步操作中，比如 AJAX 请求、事件监听器的回调、定时器等。下面详细介绍如何解决前端开发中的竞态问题。

#### 常见的竞态问题场景

1. **多次请求同一资源**：例如，当用户快速点击按钮时，可能会触发多次 AJAX 请求。
2. **状态更新冲突**：多个异步操作可能同时更新同一个状态，导致数据不一致。
3. **异步回调顺序**：多个异步操作的回调函数执行顺序不确定，可能导致逻辑错误。

#### 解决竞态问题的方法

##### 1. 使用 Promises 和 async/await

Promises 和 async/await 可以帮助你更好地控制异步操作的执行顺序，避免竞态问题。

**示例代码**：

```javascript
async function fetchData(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error fetching data:', error);
  }
}

// 使用 async/await 控制异步操作顺序
(async function() {
  await fetchData('https://api.example.com/data1');
  await fetchData('https://api.example.com/data2');
})();
```

##### 2. 使用防抖（Debounce）和节流（Throttle）

防抖（Debounce）和节流（Throttle）技术可以减少不必要的重复操作，防止在短时间内触发多次异步请求或事件处理。

**防抖（Debounce）**：

```javascript
function debounce(func, wait) {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), wait);
  };
}

const buttonClickHandler = debounce(function() {
  console.log('Button clicked');
}, 300);
```

**节流（Throttle）**：

```javascript
function throttle(func, limit) {
  let inThrottle;
  return function() {
    const args = arguments;
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

const resizeHandler = throttle(function() {
  console.log('Window resized');
}, 200);
```

##### 3. 使用锁机制（Lock）

在某些情况下，可以使用锁机制来确保同一时间内只有一个操作可以执行。这种方法适用于状态更新等场景。

**示例代码**：

```javascript
let lock = false;

function updateState(newState) {
  if (lock) return;
  lock = true;
  // 更新状态
  console.log('State updated to:', newState);
  // 模拟异步操作
  setTimeout(() => {
    lock = false;
  }, 1000);
}

document.getElementById('button').addEventListener('click', () => {
  updateState('new state');
});
```

##### 4. 使用原子操作

在更新状态时，尽量使用不可分割的操作，确保状态的一致性。

**示例代码**：

```javascript
let counter = 0;

function incrementCounter() {
  // 原子操作
  counter++;
  console.log('Counter incremented to:', counter);
}

incrementCounter();
incrementCounter();
```

##### 5. 使用状态管理库

状态管理库如 Redux、MobX 等可以帮助你更好地管理应用的状态，避免竞态问题。

**Redux 示例**：

```javascript
import { createStore } from 'redux';
import { Provider } from 'react-redux';

const initialState = { count: 0 };

function reducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    default:
      return state;
  }
}

const store = createStore(reducer);

function App() {
  return (
    <Provider store={store}>
      <button onClick={() => store.dispatch({ type: 'INCREMENT' })}>
        Increment
      </button>
      <p>{store.getState().count}</p>
    </Provider>
  );
}
```

##### 6. 使用中间件

在使用 Redux 等状态管理库时，可以使用中间件如 `redux-thunk` 或 `redux-saga` 来处理异步操作，并确保操作的顺序。

**Redux Thunk 示例**：

```javascript
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import { Provider } from 'react-redux';

const initialState = { count: 0 };

function reducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    default:
      return state;
  }
}

const store = createStore(reducer, applyMiddleware(thunk));

function incrementAsync() {
  return (dispatch) => {
    setTimeout(() => {
      dispatch({ type: 'INCREMENT' });
    }, 1000);
  };
}

function App() {
  return (
    <Provider store={store}>
      <button onClick={incrementAsync}>
        Increment Async
      </button>
      <p>{store.getState().count}</p>
    </Provider>
  );
}
```

### 总结

解决前端竞态问题的关键在于控制异步操作的执行顺序和频率。通过使用 Promises 和 async/await、防抖和节流技术、锁机制、原子操作、状态管理库以及中间件等方法，可以有效地避免竞态问题的发生，提高应用的可靠性和性能。在实际开发中，根据具体情况选择合适的方法来解决竞态问题是至关重要的。





## 其他

### 什么是服务端渲染？

服务端渲染（Server-Side Rendering，简称 SSR）是一种**将网页内容在服务器端动态生成并发送给客户端的技术**。传统的客户端渲染（Client-Side Rendering，简称 CSR）是在客户端浏览器中使用 JavaScript 动态生成页面内容。

在传统的客户端渲染中，浏览器首先下载一个空的 HTML 页面，然后通过 JavaScript 请求数据并生成页面内容。这种方式的优点是可以提供更丰富的交互和动态效果，但也存在一些缺点。例如，搜索引擎爬虫可能无法正确解析和索引页面内容，导致 SEO（搜索引擎优化）问题。同时，初始加载时用户可能会看到空白的页面或者出现闪烁的内容。

相比之下，服务端渲染通过在服务器上预先生成完整的 HTML 页面，将其发送给客户端浏览器。这样，浏览器在接收到页面时就能够立即显示完整的内容，而不需要等待 JavaScript 的下载和执行。这样可以提高页面的加载速度和首次渲染速度，并且对于搜索引擎爬虫来说更容易解析和索引页面内容，有利于 SEO。

客户端渲染：获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。

服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

- 优点：首屏渲染快，SEO 好。
- 缺点：配置麻烦，增加了服务器的计算压力。

#### 客户端渲染过程

1. 访问客户端渲染的网站。
2. 服务器返回一个包含了引入资源语句和 `<div id="app"></div>` 的 HTML 文件。
3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 `new Vue()` 开始实例化并渲染页面。

#### 服务端渲染过程

1. 访问服务端渲染的网站。
2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。
3. 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 `new Vue()` 开始实例化并接管页面。

从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。



### Nuxt.js、Next.js、Nest.js的区别

- Nuxt.js 和 Next.js 都是用于构建服务器渲染应用的框架（SSR），分别基于 Vue.js 和 React。
- Nuxt.js 适用于构建 Vue.js 应用程序，提供了默认的配置和约定，使得开发 SSR 应用更加简单。
- Next.js 适用于构建 React 应用程序，具有出色的性能和开发体验，并支持静态生成和服务器端渲染。
- Nest.js 是一个用于构建 Node.js 服务器端应用的框架，结合了 TypeScript 和面向对象编程的概念，提供了模块化的架构设计和丰富的功能。



### 什么是SEO，怎么解决SEO不友好

seo是搜索引擎优化。在搜索引擎自然排名机制的基础上,对网站进行内部及外部的调整优化,改进网站在搜索引擎中的关键词自然排名,获得更多的流量

单页面的内容是根据路由变化动态生成并展示出来的，很多页面的内容是通过ajax异步获取的,网络抓取工具并不会等待异步请求完成后再行抓取页面内容

搜索引擎爬虫是不会等待异步请求数据结束后再抓取信息的

解决方式可以使用`SSR(服务端渲染)`或者是`预渲染`



### requestAnimationFrame和setTimeout有什么区别？

引擎层面：setTimeout 属于 JS 引擎，存在事件轮询，存在事件队列。requestAnimationFrame 属于 GUI 引擎，发生在渲染过程的中重绘重排部分，与电脑分辨率保持一致。

性能层面：当页面被隐藏或最小化时，定时器 setTimeout 仍在后台执行动画任务。当页面处于未激活的状态下，该页面的屏幕刷新任务会被系统暂停，requestAnimationFrame 也会停止。

应用层面：利用 setTimeout，这种定时机制去做动画，模拟固定时间刷新页面。requestAnimationFrame 由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，在特定性环境下可以有效节省了CPU 开销









