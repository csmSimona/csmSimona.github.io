# 前端框架及项目面试

## React使用

### React基本使用

#### JSX语法

- 变量、表达式

  我们可以在JSX中使用JS表达式（不能适用于语句），表达式写在大括号“{}”中

  - `{2+2}`  `{user.firstName}`  `{formatName(user)}`

  - 在JSX中不能使用if-else语句，但可以使用conditional（三元运算）表达式来替代

    ```js
    const show = true;
    {show ? <img src="xxx.png"/> : ''}
    ```

  - 循环

    ```js
    const list = [1, 2, 3, 4, 5];
    {
        list.map((item, index) => {
            return <li key={index}>{item}</li>
        })
    }
    ```

- class style

  - React推荐使用内联样式。我们可以使用camelCase语法设置内联样式。

    React会在指定元素数字后自动添加px

    ```js
    var myStyle = {
        fontSize: 100,  // css中为font-size
        color: '#FF0000'
    };
    <h1 style={myStyle}>xxx</h1>
    ```

  - ```js
    <h1 style = {{background: red;}}>xxx</h1> //两个大括号
    ```

  - ```js
    .red-btn {
        background: red;
    }
    <h1 className='red-btn'>xxx</h1>  // 使用className而不是class
    ```

- 原生HTML

  ```js
  var item = `<h1>hello</h1>`
  <li
  	key={index}
  	onClick={this.handleItemDelete.bind(this, index)}
      dangerouslySetInnerHTML={__html: item}
  >
  </li>
  ```

#### 子元素和组件

#### 条件渲染

- if else

  ```js
  const whiteBtn = <button className="btn-white">white btn</button>
  const blackBtn = <button className="btn-black">black btn</button>
  
  if (this.state.theme === 'black') {
      return blackBtn
  } else {
      return whiteBtn
  }
  ```

- 三元表达式

  ```js
  return <div>
      { this.state.theme === 'black' ? blackBtn : whiteBtn }
  </div>
  ```

- 逻辑运算符 &&  ||

  ```js
  return <div>
      { this.state.theme === 'black' && blackBtn }
  </div>
  ```

- 列表渲染

  - map

    ```js
    class ListDemo extends React.Component {
        constructor(props) {
            super(props)
            this.state = {
                list: [
                    {
                        id: 'id1',
                        title: 'title1'
                    },
                    {
                        id: 'id2',
                        title: 'title2'
                    },
                    {
                        id: 'id3',
                        title: 'title3'
                    }
                ]
            }
        }
        render() {
            return <ul>{this.state.list.map((item, index) => {
                return <li key={item.id}>index {index}; title {item.title}</li>
            })}</ul>
        }
    }
    ```

  - key

#### 事件

- bind this

  ```js
  // 将这种作用域的修改放在constructor中，保证作用域绑定操作只执行一次。
  this.handleBtnClick = this.handleBtnClick.bind(this) //绑定this为对应组件<TodoList/>
  
  <button className="button" onClick={this.handleBtnClick}>提交</button>
  
  handleBtnClick() {
      // console.log(this)  // this默认是undefined
      this.setState({
          inputValue: ''
      })
  }
  
  // 用静态方法，this指向当前实例 不需要再绑定this
  handleBtnClick = () => {
      this.setState({
          inputValue: ''
      })
  }
  ```

- 关于event参数

  ```js
  handleBtnClick = (event) => {
      event.preventDefault()  // 阻止默认行为
      event.stopPropagation() // 阻止冒泡
      console.log('target', event.target)  // 指向当前元素，即当前元素触发
      console.log('current target', event.currentTarget) // 指向当前元素，假象！
      
      // 注意，event其实是React封装的。可以看__proto__constructor是 SyntheticEvent
      conole.log('event', event)
      
      // 原生event（event.nativeEvent）如下。其__proto__constructor是 MouseEvent
      console.log('NativeEvent', event.nativeEvent)
      console.log('NativeEvent target', event.nativeEvent.target) //指向当前元素
      console.log('NativeEvent current target', event.nativeEvent.currentTarget)
  	// 指向document元素/root组件
  }
  ```

  **版本升级**

  React16绑定到document

  **React17事件绑定到root组件**

  有利于多个React版本并存，例如微前端

- 传递自定义参数

  ```js
  <button className="button" onClick={this.handleBtnClick(id, title)}>提交</button>
  
  handleBtnClick(id, title, event) {
      console.log(id, title)
      console.log('event', event)  // 最后追加一个参数，即可接收event
  }
  ```

#### 表单

- 受控组件

  ```js
  render() {
      return <div>
          <p>{this.state.name}</p>
          <label htmlFor="inputName">姓名：</label> {/* 用 htmlFor 代替 for */}
          <input id="inputName" value={this.state.name} onChange={this.onInputChange}/>
      </div>
  }
  onInputChange = (e) => {
      this.setState({
          name: e.target.value
      })
  }
  ```

- input textarea select 用value

- checkbox radio 用checked

- 组件和props（类型检查）

  - props传递数据
  - props传递函数
  - props类型检查

  ```js
  import React from 'react'
  import PropTypes from 'prop-types'
  
  class Input extends React.Component {
      constructor(props) {
          super(props)
          this.state = {
              title: ''
          }
      }
      render() {
          return <div>
              <input value={this.state.title} onChange={this.onTitleChange}/>
              <button onClick={this.onSubmit}>提交</button>
          </div>
      }
      onTitleChange = (e) => {
          this.setState({
              title: e.target.value
          })
      }
      onSubmit = () => {
          const { submitTitle } = this.props
          submitTitle(this.state.title) // 'abc'
  
          this.setState({
              title: ''
          })
      }
  }
  // props 类型检查
  Input.propTypes = {
      submitTitle: PropTypes.func.isRequired
  }
  
  class List extends React.Component {
      constructor(props) {
          super(props)
      }
      render() {
          const { list } = this.props
  
          return <ul>{list.map((item, index) => {
              return <li key={item.id}>
                  <span>{item.title}</span>
              </li>
          })}</ul>
      }
  }
  // props 类型检查
  List.propTypes = {
      list: PropTypes.arrayOf(PropTypes.object).isRequired
  }
  
  class Footer extends React.Component {
      constructor(props) {
          super(props)
      }
      render() {
          return <p>
              {this.props.text}
              {this.props.length}
          </p>
      }
      componentDidUpdate() {
          console.log('footer did update')
      }
      shouldComponentUpdate(nextProps, nextState) {
          if (nextProps.text !== this.props.text
              || nextProps.length !== this.props.length) {
              return true // 可以渲染
          }
          return false // 不重复渲染
      }
  
      // React 默认：父组件有更新，子组件则无条件也更新！！！
      // 性能优化对于 React 更加重要！
      // SCU 一定要每次都用吗？—— 需要的时候才优化
  }
  
  class TodoListDemo extends React.Component {
      constructor(props) {
          super(props)
          // 状态（数据）提升
          this.state = {
              list: [
                  {
                      id: 'id-1',
                      title: '标题1'
                  },
                  {
                      id: 'id-2',
                      title: '标题2'
                  },
                  {
                      id: 'id-3',
                      title: '标题3'
                  }
              ],
              footerInfo: '底部文字'
          }
      }
      render() {
          return <div>
              <Input submitTitle={this.onSubmitTitle}/>
              <List list={this.state.list}/>
              <Footer text={this.state.footerInfo} length={this.state.list.length}/>
          </div>
      }
      onSubmitTitle = (title) => {
          this.setState({
              list: this.state.list.concat({
                  id: `id-${Date.now()}`,
                  title
              })
          })
      }
  }
  
  export default TodoListDemo
  ```

#### state和setState（重点）

- 不可变值

  ```js
  // 不可变值（函数式编程，纯函数） - 数组
  const list5Copy = this.state.list5.slice()
  list5Copy.splice(2, 0, 'a') // 中间插入/删除
  this.setState({
      list1: this.state.list1.concat(100), // 追加
      list2: [...this.state.list2, 100], // 追加
      list3: this.state.list3.slice(0, 3), // 截取
      list4: this.state.list4.filter(item => item > 100), // 筛选
      list5: list5Copy // 其他操作
  })
  // 注意，不能直接对 this.state.list 进行 push pop splice 等，这样违反不可变值
  ```

  

- 可能是异步更新

  ```js
  this.setState({
      count: this.state.count + 1
  }, () => {
      // 联想 Vue $nextTick - DOM
      console.log('count by callback', this.state.count) // 回调函数中可以拿到最新的 state
  })
  console.log('count', this.state.count) // 异步的，拿不到最新值
  ```

  ```js
  // setTimeout 中 setState 是同步的
  setTimeout(() => {
      this.setState({
          count: this.state.count + 1
      })
      console.log('count in setTimeout', this.state.count)
  }, 0)
  ```

  ```js
  // 自己定义的 DOM 事件，setState 是同步的
  bodyClickHandler = () => {
      this.setState({
          count: this.state.count + 1
      })
      console.log('count in body event', this.state.count)
  }
  componentDidMount() {
      // 自己定义的 DOM 事件，setState 是同步的
      document.body.addEventListener('click', this.bodyClickHandler)
  }
  componentWillUnmount() {
      // 及时销毁自定义 DOM 事件
      document.body.removeEventListener('click', this.bodyClickHandler)
      // clearTimeout
  }
  ```

- 可能会被合并

  ```js
  // 传入对象，会被合并（类似 Object.assign ）。执行结果只一次 +1
  this.setState({
      count: this.state.count + 1
  })
  this.setState({
      count: this.state.count + 1
  })
  this.setState({
      count: this.state.count + 1
  })
  
  // 传入函数，不会被合并。执行结果是 +3
  this.setState((prevState, props) => {
      return {
          count: prevState.count + 1
      }
  })
  this.setState((prevState, props) => {
      return {
          count: prevState.count + 1
      }
  })
  this.setState((prevState, props) => {
      return {
          count: prevState.count + 1
      }
  })
  ```

#### 组件生命周期

[React 组件生命周期图示](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

- constructor：在组件一创建的时刻就被调用。但不归类在React的生命周期中，因为它是ES6里面的东西，不是React独有的。
- componentWillMount：在组件即将被挂载到页面的时刻自动执行。
- componentDidMount：在组件被挂载后自动执行。
- shouldComponentUpdate：组件被更新之前，自动被执行需要返回一个布尔值。true 更新 false 不会被更新
- componentWillUpdate：组件被更新之前，它会自动执行，但是它在shouldComponentUpdate之后被执行，如果返回true就执行，如果返回false，这个函数就不会被执行了。
- componentDidUpdate：组件被更新之后自动执行。
- componentWillReceiveProps：一个组件要从父组件接受参数。只要父组件的render函数被重新执行了，子组件的这个生命周期函数就会被执行（如果这个组件第一次存在与父组件中，不会执行；如果这个组件之前已经存在于父组件中，才会执行）
- componentWillUnmount：当这个组件即将被从页面中剔除的时候，会被执行。



### React高级特性

#### 函数组件

- 纯函数，输入props，输出JSX
- 没有组件实例
- 没有生命周期
- 没有state和setState，只能接收props
- 不能扩展其他方法

#### 非受控组件

- ref
- defaultValue defaultChecked
- 手动操作DOM元素
- 使用场景：必须手动操作DOM 元素，setState实现不了的。如文件上传、某些富文本编辑器，需要传入DOM元素

```js
import React from 'react'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            name: '双越',
            flag: true,
        }
        this.nameInputRef = React.createRef() // 创建 ref
    }
    render() {
        // input defaultValue
        return <div>
            {/* 使用 defaultValue 而不是 value ，使用 ref */}
            <input defaultValue={this.state.name} ref={this.nameInputRef}/>
            {/* state 并不会随着改变 */}
            <span>state.name: {this.state.name}</span>
            <br/>
            <button onClick={this.alertName}>alert name</button>
        </div>

    }
    alertName = () => {
        const elem = this.nameInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.value) // 不是 this.state.name
    }
}

export default App
```

```js
import React from 'react'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.fileInputRef = React.createRef()
    }
    render() {
        // file
        return <div>
            <input type="file" ref={this.fileInputRef}/>
            <button onClick={this.alertFile}>alert file</button>
        </div>

    }
    alertFile = () => {
        const elem = this.fileInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.files[0].name)
    }
}

export default App
```

受控组件VS非受控组件

优先使用受控组件，符合React设计原则；必须操作DOM时，再使用非受控组件

- Portals

  - 组件默认会按照既定层次嵌套渲染
  - 如何让组件渲染到父组件以外
  - 使用场景
    - overflow: hidden
    - 父组件z-index值太小
    - fixed需要放在body第一层级

  ```js
  import React from 'react'
  import ReactDOM from 'react-dom'
  import './style.css'
  
  class App extends React.Component {
      constructor(props) {
          super(props)
          this.state = {
          }
      }
      render() {
          // // 正常渲染
          // return <div className="modal">
          //     {this.props.children} {/* vue slot */}
          // </div>
  
          // 使用 Portals 渲染到 body 上。
          // fixed 元素要放在 body 上，有更好的浏览器兼容性。
          return ReactDOM.createPortal(
              <div className="modal">{this.props.children}</div>,
              document.body // DOM 节点
          )
      }
  }
  
  export default App
  ```

#### context

优点：变量不用层层传递，省去无谓的传递props

缺点：使用全局变量的方法，会让组件失去独立性，复用起来更困难，会让组件变得不纯粹，不应该大规模使用。

- 公共信息（语言、主题）传递给每个组件

```js
import React from 'react'

// 创建 Context 填入默认值（任何一个 js 变量）
const ThemeContext = React.createContext('light')

// 底层组件 - 函数式组件
function ThemeLink (props) {
    // const theme = this.context // 会报错。函数式组件没有实例，即没有 this

    // 函数式组件可以使用 Consumer
    return <ThemeContext.Consumer>
        { value => <p>link's theme is {value}</p> }
    </ThemeContext.Consumer>
}

// 底层组件 - class 组件
class ThemedButton extends React.Component {
    // 指定 contextType 读取当前的 theme context。
    // static contextType = ThemeContext // 也可以用 ThemedButton.contextType = ThemeContext
    render() {
        const theme = this.context // React 会往上找到最近的 theme Provider，然后使用它的值。
        return <div>
            <p>button's theme is {theme}</p>
        </div>
    }
}
ThemedButton.contextType = ThemeContext // 指定 contextType 读取当前的 theme context。

// 中间的组件再也不必指明往下传递 theme 了。
function Toolbar(props) {
    return (
        <div>
            <ThemedButton />
            <ThemeLink />
        </div>
    )
}

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            theme: 'light'
        }
    }
    render() {
        return <ThemeContext.Provider value={this.state.theme}>
            <Toolbar />
            <hr/>
            <button onClick={this.changeTheme}>change theme</button>
        </ThemeContext.Provider>
    }
    changeTheme = () => {
        this.setState({
            theme: this.state.theme === 'light' ? 'dark' : 'light'
        })
    }
}

export default App
```

#### 异步组件

- import()
- React.lazy
- React.Suspense

```js
import React from 'react'

const ContextDemo = React.lazy(() => import('./ContextDemo'))

class App extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return <div>
            <p>引入一个动态组件</p>
            <hr />
            <React.Suspense fallback={<div>Loading...</div>}>
                <ContextDemo/>
            </React.Suspense>
        </div>

        // 1. 强制刷新，可看到 loading （看不到就限制一下 chrome 网速）
        // 2. 看 network 的 js 加载
    }
}

export default App
```



#### :star:性能优化（其中高阶组件值得关注）

##### shouldComponentUpdate（简称SCU）

```js
shouldComponentUpdate(nextProps, nextState) {
    if (nextState.count !== this.state.count) {
        return true // 可以渲染
    }
    return false // 不重复渲染
}
```

React 默认：父组件有更新，子组件则无条件也更新

SCU默认返回true



##### PureComponent和React.memo

- PureComponent SCU中实现了浅比较

- memo 函数组件中的PureComponent 

  ```js
  function MyComponent(props) {
      // 使用props渲染
  }
  function areEqual(prevProps, nextProps) {
      /* 如果把nextProps传入render方法的返回结果与
      	将prevProps传入render方法的返回结果一致则返回true
      	否则返回false
      */
  }
  export default React.memo(MyComponent, areEqual)
  ```

- 浅比较已使用大部分情况（尽量不要做深度比较）



##### 不可变值 immutable.js

immutable对象是不可直接赋值的对象,它可以有效的避免错误赋值的问题



##### :star:高阶组件HOC

这篇文章推荐阅读：[高阶组件（HOC）在 React 中的应用](https://juejin.cn/post/7220677873584734268)

- 高阶组件（HOC）是一个接收组件作为参数并返回一个新组件的函数。换句话说，它是一种组件的转换器。

- 高阶组件通常用于在组件之间复用逻辑，例如状态管理、数据获取、访问控制等。

- HOC 的一个常见示例是 React-Redux 的 `connect` 函数，它将 Redux store 连接到 React 组件，使组件可以访问和更新 store 中的状态。
- 我在实际工作中应用在了权限控制和错误边界中（看上面发的文章）



基本使用

```js
// 高阶组件不是一种功能，而是一种模式
const HOCFactory = (Component) => {
    class HOC extends React.Component {
        render() {
            // 返回拼装的结果
            return <Component {...this.props}/> 
        }
    }
    return HOC
}
const EnhancesComponent1 = HOCFactory(WrappedComponent1)
const EnhancesComponent2 = HOCFactory(WrappedComponent2)
```



例子

```js
import React from 'react'

// 高阶组件
const withMouse = (Component) => {
    class withMouseComponent extends React.Component {
        constructor(props) {
            super(props)
            this.state = { x: 0, y: 0 }
        }
  
        handleMouseMove = (event) => {
            this.setState({
                x: event.clientX,
                y: event.clientY
            })
        }
  
        render() {
            return (
                <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
                    {/* 1. 透传所有 props 2. 增加 mouse 属性 */}
                    <Component {...this.props} mouse={this.state}/>
                </div>
            )
        }
    }
    return withMouseComponent
}

const App = (props) => {
    const a = props.a
    const { x, y } = props.mouse // 接收 mouse 属性
    return (
        <div style={{ height: '500px' }}>
            <h1>The mouse position is ({x}, {y})</h1>
            <p>{a}</p>
        </div>
    )
}

export default withMouse(App) // 返回高阶函数
```



redux connect 是高阶组件

```js
import { connect } from 'react-redux'
// connect是高阶组件
const VisibleTodoList = connect(
	mapStateToProps,
    mapDispatchToProps
)(TodoList)

export default VisibleTodolList
```




#### Render Props

基本使用

```js
// Render Props的核心思想
// 通过一个函数将class组件的state作为props传递给纯函数组件
class Factory extends React.Component {
    constructor() {
        this.state = {
            // state即多个组件的公共逻辑的数据
        }
    }
    // 修改state
    render() {
        return <div>{this.props.render(this.state)}</div>
    }
}

const App = () => (
    <Factory render={
        // render是一个函数组件
        (props)=> <p>{props.a} {props.b} ... </p>
    }/>
)
```

例子

```js
import React from 'react'
import PropTypes from 'prop-types'

class Mouse extends React.Component {
    constructor(props) {
        super(props)
        this.state = { x: 0, y: 0 }
    }
  
    handleMouseMove = (event) => {
      this.setState({
        x: event.clientX,
        y: event.clientY
      })
    }
  
    render() {
      return (
        <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
            {/* 将当前 state 作为 props ，传递给 render （render 是一个函数组件） */}
            {this.props.render(this.state)}
        </div>
      )
    }
}
Mouse.propTypes = {
    render: PropTypes.func.isRequired // 必须接收一个 render 属性，而且是函数
}

const App = (props) => (
    <div style={{ height: '500px' }}>
        <p>{props.a}</p>
        <Mouse render={
            /* render 是一个函数组件 */
            ({ x, y }) => <h1>The mouse position is ({x}, {y})</h1>
        }/>
        
    </div>
)

/**
 * 即，定义了 Mouse 组件，只有获取 x y 的能力。
 * 至于 Mouse 组件如何渲染，App 说了算，通过 render props 的方式告诉 Mouse 。
 */

export default App
```

HOC VS Render Props

- HOC：模式简单 但会增加组件层级
- Render Props：代码简洁，学习成本较高
- 按需使用



### Redux使用

**基本概念**

具体看[react基础 - redux](../前端基础汇总/react基础.md)

- store state
- action
- reducer

**单向数据流**

- dispatch(action)
- reducer => newState
- subscribe触发通知

**react-redux**

运用Provider将组件和store对接，使在Provider里的所有组件都能共享store里的数据，

使用connect将 Redux store 和 React 组件连接，使组件可以访问和更新 store 中的状态。

- Provider：作用：连接store，内部组件都有能力获取store的内容

- connect：组件与store作连接

- mapStateToProps：把store中state映射成组件中的props

- mapDispatchToProps：将store.dispatch挂载到props上

**异步action**

```js
// 同步action
export const addTodo = text => {
    // 返回action对象
    return {
        type: 'ADD_TODO',
        id: nextTodoId++,
        text
    }
}
```

```js
// 异步action
export const addTodoAsync = text => {
    // 返回函数，其中有dispatch参数
    return (dispatch) => {
        // ajax 异步获取数据
        fetch(url).then(res => {
            // 执行异步 action
            dispatch(addTodo(res.text))
        })
    }
}
```

**中间件**

**redux数据流图**

![redux数据流图](..\picture\redux数据流图.jpg)

### React-router使用

- 路由模式（hash、H5 history），同vue-router
- 路由配置（动态路由、懒加载），同vue-router

![react-router路由模式](..\picture\react-router路由模式.jpg)

![react-router动态路由](..\picture\react-router动态路由.jpg)

![react-router跳转路由](..\picture\react-router跳转路由.jpg)

![react-router懒加载](..\picture\react-router懒加载.jpg)



## React原理

### 函数式编程

- 纯函数
- 不可变值

### vdom和diff

以上述vue中类似

vdom

- h函数
- vnode数据结构
- patch函数

diff

- 只比较同一层级，不跨级比较
- tag不相同，则直接删掉重建，不再深度比较
- tag和key，两者都相同，则认为是相同节点，不再深度比较

### JSX本质

```js
const imgElem = <div id="div1">
    <p>some text</p>
	<img src={imgUrl} />
</div>


// 编译后
React.createElement("div", {
    id: "div1"
}, React.createElement("p", null, "some text"), React.createElement("img", {
    src: imgUrl
}))
```

### 合成事件

React16

- 所有事件挂载到document上
- event不是原生的，是SyntheticEvent合成事件对象
- 和Vue事件不同，和DOM事件也不同

为何要合成事件机制？

- 更好的兼容性和跨平台
- 挂载到document，减少内存消耗，避免频繁解绑
- 方便事件的统一管理（如事务机制）



React17

- 绑定到root组件上
- 有利于多个React版本并存，例如微前端



### setState 和 batchUpdate

setState异步还是同步？

- 无所谓同步还是异步
- 看是否能命中batchUpdate机制
- 判断isBatchingUpdates

#### setState主流程

![setState主流程](..\picture\setState主流程.jpg)

#### batchUpdate机制

**isBatchingUpdates**

![isBatchingUpdates](..\picture\isBatchingUpdates.jpg)



哪些能命中batchUpdate机制

- 生命周期（和它调用的函数）
- React中注册的事件（和它调用的函数）
- React可以“管理”的入口

哪些不能命中batchUpdate机制

- setTimeout setInterval等（和它调用的函数）
- 自定义的DOM事件（和它调用的函数）
- React“管不到”的入口



#### transaction（事务）机制

![transaction事务机制](..\picture\transaction事务机制.jpg)





### 组件渲染过程

- props state
- render() 生成 vnode
- patch(elem, vnode)

组件更新过程

- setState(newState) => dirtyComponents（可能有子组件）
- render() 生成 newVnode
- patch(vnode, newVnode)

patch拆分成两个阶段：

1、reconciliation阶段：执行diff算法，纯JS计算

2、commit阶段：将diff结果渲染DOM



可能会有性能问题

- JS是单线程，且和DOM渲染共用一个线程
- 当组件足够复杂，组件更新时计算和渲染都压力大
- 同时再有DOM操作需求（动画，鼠标拖拽等），将卡顿



性能优化解决方案：react-fiber

- 将reconciliation阶段进行任务拆分成子任务
- 子任务的执行在DOM需要渲染时暂停，空闲时恢复
- window.requestIdleCallback



### 面试真题演练

#### 组件之间如何通讯

- 父子组件props
- 自定义事件
- Redux
- Context

#### JSX本质是什么

- createElement
- 执行返回vnode

#### React发起ajax应该在哪个生命周期

- 同Vue
- componentDidMount

#### 渲染列表为何使用key

- 同Vue。必须用key，且不能是index和random
- diff算法中通过tag和key来判断是否是sameNode
- 减少渲染次数，提升渲染性能

#### 多个组件有公共逻辑，如何抽离

- 高阶组件
- Render Props
- mixin 已被React废弃

#### :star:React性能优化

- 渲染列表时加key
- 自定义事件、DOM事件及时销毁
- 合理使用异步组件
- 减少函数 bind this 的次数
- 合理使用SCU PureComponent 和memo
- 合理使用Immutable.js
- webpack层面的优化
- 前端通用的性能优化，如图片懒加载
- 使用SSR

#### :star:React和Vue的区别

- 都支持组件化
- 都是数据驱动视图
- 都使用vdom操作DOM

- React使用JSX拥抱JS，Vue使用模板拥抱html

- React函数式编程，Vue声明式编程
- React需要更多的自力更生，Vue把想要的都给你



## React Hooks

### State Hook

#### 作用：让函数组件实现 state 和 setState

- 默认函数组件没有state
- 函数组件是一个纯函数，执行完即销毁，无法存储state
- 需要State Hook，即把state功能“钩”到纯函数中

#### useState使用总结

- `useState(0)`传入初始值，返回数组[state, setState]
- 通过state获取值
- 通过`setState(1)`修改值

#### Hooks命名规范

- 规定所有的Hooks都用use开头，如useXxx
- 自定义Hook也要以use开头
- 非Hooks的地方，尽量不要使用useXxx写法

#### 代码演示

```js
import React, { useState } from 'react'

function ClickCounter() {
    // 数组的解构
    // useState 就是一个 Hook “钩”，最基本的一个 Hook
    const [count, setCount] = useState(0) // 传入一个初始值

    function clickHandler() {
        setCount(count + 1)
    }

    return <div>
        <p>你点击了 {count} 次</p>
        <button onClick={clickHandler}>点击</button>
    </div>
}

export default ClickCounter
```



### Effect Hook

#### 作用：让组件模拟生命周期

- 默认函数组件没有生命周期
- 函数组件是一个纯函数，执行完即销毁，自己无法实现生命周期
- 使用Effect Hook 把生命周期“钩”到纯函数中

#### useEffect使用总结

- 模拟 componentDidMount - useEffect 依赖 []

- 模拟 componentDidUpdate - useEffect 无依赖， 或者依赖 [a, b]

- 模拟 componentWillUnMount - useEffect 中返回一个函数fn

  - useEffect依赖[]，组件销毁时执行fn，等于WillUnMounted
  - useEffect无依赖或依赖[a, b]，组件更新时执行fn
  - 即，下一次执行useEffect之前，就会执行fn，无论更新或卸载

  

#### 代码演示

```js
import React, { useState, useEffect } from 'react'

function LifeCycles() {
    const [count, setCount] = useState(0)

    // 模拟 class 组件的 DidMount 和 DidUpdate
    useEffect(() => {
        console.log('在此发送一个 ajax 请求')
    })

    // 模拟 class 组件的 DidMount
    useEffect(() => {
        console.log('加载完了')
    }, []) // 第二个参数是 [] （不依赖于任何 state）

    // 模拟 class 组件的 DidUpdate
    useEffect(() => {
        console.log('更新了')
    }, [count]) // 第二个参数就是依赖的 state

    // 模拟 class 组件的 DidMount
    useEffect(() => {
        let timerId = window.setInterval(() => {
            console.log(Date.now())
        }, 1000)

        // 返回一个函数
        // 模拟 WillUnMount
        return () => {
            window.clearInterval(timerId)
        }
    }, [])

    function clickHandler() {
        setCount(count + 1)
    }

    return <div>
        <p>你点击了 {count} 次</p>
        <button onClick={clickHandler}>点击</button>
    </div>
}

export default LifeCycles
```

#### 模拟WillUnMount，但不完全相等

- useEffect依赖[]，组件销毁时执行fn，等于WillUnMounted
- useEffect无依赖或依赖[a, b]，组件更新时执行fn
- 即，下一次执行useEffect之前，就会执行fn，无论更新或卸载

```js
import React, { useState, useEffect } from 'react'

function FriendStatus({ friendId }) {
    const [status, setStatus] = useState(false)

    // DidMount 和 DidUpdate
    useEffect(() => {
        console.log(`开始监听 ${friendId} 在线状态`)

        // 【特别注意】
        // 此处并不完全等同于 WillUnMount
        // props 发生变化，即更新，也会执行结束监听
        // 准确的说：返回的函数，会在下一次 effect 执行之前，被执行
        return () => {
            console.log(`结束监听 ${friendId} 在线状态`)
        }
    })

    return <div>
        好友 {friendId} 在线状态：{status.toString()}
    </div>
}

export default FriendStatus
```





### 其他 Hook

#### useRef

```js
import React, { useRef, useEffect } from 'react'

function UseRef() {
    const btnRef = useRef(null) // 初始值

    // const numRef = useRef(0)
    // numRef.current

    useEffect(() => {
        console.log(btnRef.current) // DOM 节点
    }, [])

    return <div>
        <button ref={btnRef}>click</button>
    </div>
}

export default UseRef
```



#### useContext

```js
import React, { useContext } from 'react'

// 主题颜色
const themes = {
    light: {
        foreground: '#000',
        background: '#eee'
    },
    dark: {
        foreground: '#fff',
        background: '#222'
    }
}

// 创建 Context
const ThemeContext = React.createContext(themes.light) // 初始值

function ThemeButton() {
    const theme = useContext(ThemeContext)

    return <button style={{ background: theme.background, color: theme.foreground }}>
        hello world
    </button>
}

function Toolbar() {
    return <div>
        <ThemeButton></ThemeButton>
    </div>
}

function App() {
    return <ThemeContext.Provider value={themes.dark}>
        <Toolbar></Toolbar>
    </ThemeContext.Provider>
}

export default App
```



#### useReducer

```js
import React, { useReducer } from 'react'

const initialState = { count: 0 }

const reducer = (state, action) => {
    switch (action.type) {
        case 'increment':
            return { count: state.count + 1 }
        case 'decrement':
            return { count: state.count - 1 }
        default:
            return state
    }
}

function App() {
    // 很像 const [count, setCount] = useState(0)
    const [state, dispatch] = useReducer(reducer, initialState)

    return <div>
        count: {state.count}
        <button onClick={() => dispatch({ type: 'increment' })}>increment</button>
        <button onClick={() => dispatch({ type: 'decrement' })}>decrement</button>
    </div>
}

export default App
```

##### useReducer 和 redux 的区别

- useReducer是useState的代替方案，用于state复杂变化
- useReducer是单个组件状态管理，组件通讯还需要props
- redux是全局的状态管理，多组件共享数据



#### useMemo

##### useMemo使用总结

- React默认会更新所有子组件
- class组件使用SCU和PureComponent做优化
- Hooks中使用useMemo，但优化的原理是相同的
- memo封装子组件，useMemo封装数据

```js
import React, { useState, memo, useMemo } from 'react'

// 子组件
// 类似 class PureComponent ，对 props 进行浅层比较
const Child = memo(({ userInfo }) => {
    console.log('Child render...', userInfo)

    return <div>
        <p>This is Child {userInfo.name} {userInfo.age}</p>
    </div>
})

// 父组件
function App() {
    console.log('Parent render...')

    const [count, setCount] = useState(0)
    const [name, setName] = useState('双越老师')

    // const userInfo = { name, age: 20 }
    // 用 useMemo 缓存数据，有依赖
    const userInfo = useMemo(() => {
        return { name, age: 21 }
    }, [name])

    return <div>
        <p>
            count is {count}
            <button onClick={() => setCount(count + 1)}>click</button>
        </p>
        <Child userInfo={userInfo}></Child>
    </div>
}

export default App
```



#### useCallback

**useMemo缓存数据，useCallback缓存函数**

- 都用于缓存数据，优化性能

- 两者接收的参数都是一样的，第一个参数表示一个回调函数，第二个表示依赖的数据

- 在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到一个缓存的作用

区别：

- useMemo  缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态

- useCallback  缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化，会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费

  另外还需要注意的是，useCallback应该和React.memo配套使用，缺了一个都可能导致性能不升反而下降。



```js
import React, { useState, memo, useMemo, useCallback } from 'react'

// 子组件，memo 相当于 PureComponent
const Child = memo(({ userInfo, onChange }) => {
    console.log('Child render...', userInfo)

    return <div>
        <p>This is Child {userInfo.name} {userInfo.age}</p>
        <input onChange={onChange}></input>
    </div>
})

// 父组件
function App() {
    console.log('Parent render...')

    const [count, setCount] = useState(0)
    const [name, setName] = useState('双越老师')

    // 用 useMemo 缓存数据
    const userInfo = useMemo(() => {
        return { name, age: 21 }
    }, [name])

    // function onChange(e) {
    //     console.log(e.target.value)
    // }
    // 用 useCallback 缓存函数
    const onChange = useCallback(e => {
        console.log(e.target.value)
    }, [])

    return <div>
        <p>
            count is {count}
            <button onClick={() => setCount(count + 1)}>click</button>
        </p>
        <Child userInfo={userInfo} onChange={onChange}></Child>
    </div>
}

export default App
```



#### useLayoutEffect

用法与useEffect相似

区别

- `useEffect` 是异步执行的，而`useLayoutEffect`是同步执行的。
- `useEffect` 的执行时机是浏览器完成渲染之后，而 `useLayoutEffect` 的执行时机是浏览器把内容真正渲染到界面之前，和 `componentDidMount` 等价。

总结

1. 优先使用 `useEffect`，因为它是异步执行的，不会阻塞渲染
2. 会影响到渲染的操作尽量放到 `useLayoutEffect`中去，避免出现闪烁问题
3. `useLayoutEffect`和`componentDidMount`是等价的，会同步调用，阻塞渲染
4. 在服务端渲染的时候使用会有一个 warning，因为它可能导致首屏实际内容和服务端渲染出来的内容不一致。



#### useUpdateEffect

ahooks里的

`useUpdateEffect` 用法等同于 `useEffect`，但是会**忽略首次执行**，只在依赖更新时执行。



#### useMemoizedFn

ahooks里的

我在实现多页签方案时有实际使用

- 一般情况下，可以使用 useMemoizedFn 完全代替 useCallback

- 在某些场景中，我们需要使用 useCallback 来记住一个函数，但是在第二个参数 deps 变化时，会重新生成函数，导致函数地址变化。

- 使用 useMemoizedFn，可以省略第二个参数 deps，同时保证函数地址永远不会变化。



### 自定义 Hook

#### 自定义useAxios

```js
import { useState, useEffect } from 'react'
import axios from 'axios'

// 封装 axios 发送网络请求的自定义 Hook
function useAxios(url) {
    const [loading, setLoading] = useState(false)
    const [data, setData] = useState()
    const [error, setError] = useState()

    useEffect(() => {
        // 利用 axios 发送网络请求
        setLoading(true)
        axios.get(url) // 发送一个 get 请求
            .then(res => setData(res))
            .catch(err => setError(err))
            .finally(() => setLoading(false))
    }, [url])

    return [loading, data, error]
}

export default useAxios

// 第三方 Hook
// https://nikgraf.github.io/react-hooks/
// https://github.com/umijs/hooks
```

使用

```js
import React from 'react'
import useAxios from '../customHooks/useAxios'

function App() {
    const url = 'http://localhost:3000/'
    // 数组解构
    const [loading, data, error] = useAxios(url)

    if (loading) return <div>loading...</div>

    return error
        ? <div>{JSON.stringify(error)}</div>
        : <div>{JSON.stringify(data)}</div>
}

export default App
```



#### 自定义useMousePosition

```js
import { useState, useEffect } from 'react'

function useMousePosition() {
    const [x, setX] = useState(0)
    const [y, setY] = useState(0)

    useEffect(() => {
        function mouseMoveHandler(event) {
            setX(event.clientX)
            setY(event.clientY)
        }

        // 绑定事件
        document.body.addEventListener('mousemove', mouseMoveHandler)

        // 解绑事件
        return () => document.body.removeEventListener('mousemove', mouseMoveHandler)
    }, [])

    return [x, y]
}

export default useMousePosition
```

使用

```js
import React from 'react'
import useMousePosition from '../customHooks/useMousePosition'

function App() {
    const [x, y] = useMousePosition()
    return <div style={{ height: '500px', backgroundColor: '#ccc' }}>
        <p>鼠标位置 {x} {y}</p>
    </div>
}

export default App
```



#### 倒计时useInterval

ahooks中有这个功能

```js
import { useEffect, useRef } from 'react';

/**
 * 
 * @param {*} fn 回调函数
 * @param {*} delay 延迟时间
 * @param {*} options {immediate} 是否立即执行
 */
function useInterval(
    fn,
    delay,
    options,
) {
    const immediate = options?.immediate;
    const fnRef = useRef();
    fnRef.current = fn;

    useEffect(() => {
        if (typeof delay !== 'number' || delay < 0) return;
        if (immediate) {
            fnRef.current();
        }
        const timer = setInterval(() => {
            fnRef.current();
        }, delay);
        return () => {
            clearInterval(timer);
        };
    }, [delay]);
}

export default useInterval;
```

使用

```js
const [interval, setInterval] = useState(undefined);
const [count, setCount] = useState(5);
const handleGo = () => {
history.push('/');
};

useInterval(
    () => {
      if (count > 0) {
        setCount(count - 1);
      }
      if (count === 0) {
        setInterval(undefined);
        handleGo();
      }
    },
    interval,
    {
      immediate: true,
    },
  );
```



### Hooks 使用规范

- 只能用于React函数组件和自定义Hook中，其他地方不可以
- 只能用于顶层代码，不能在循环、判断中使用Hooks（Hooks严重依赖于调用顺序，如果Hooks出现在循环、判断里，则无法保证顺序一致）
- eslint插件eslint-plugin-resct-hooks可以帮到你



### 规范和注意事项

- useState初始化值，只有第一次有效

  - render: 初始化 state
  - re-render: 只恢复初始化的 state 值，不会再重新设置新的值。只能用 setName 修改

  ```js
  import React, { useState } from 'react'
  
  // 子组件
  function Child({ userInfo }) {
      // render: 初始化 state
      // re-render: 只恢复初始化的 state 值，不会再重新设置新的值
      //            只能用 setName 修改
      const [ name, setName ] = useState(userInfo.name)
  
      return <div>
          <p>Child, props name: {userInfo.name}</p>	/* 点击后会改变 */
          <p>Child, state name: {name}</p>			/* 点击后不会改变 */
      </div>
  }
  
  
  function App() {
      const [name, setName] = useState('双越')
      const userInfo = { name }
  
      return <div>
          <div>
              Parent &nbsp;
              <button onClick={() => setName('慕课网')}>setName</button>
          </div>
          <Child userInfo={userInfo}/>
      </div>
  }
  
  export default App
  ```

- useEffect内部不能修改state
  - 依赖为 [] 时： re-render 不会重新执行 effect 函数
  - 没有依赖：re-render 会重新执行 effect 函数
- useEffect可能出现死循环
  - 当依赖中有引用对象时，会出现死循环
  - 使用useRef来解决

```js
import React, { useState, useRef, useEffect } from 'react'

function UseEffectChangeState() {
    const [count, setCount] = useState(0)

    // 模拟 DidMount
    const countRef = useRef(0)
    useEffect(() => {
        console.log('useEffect...', count)

        // 定时任务
        const timer = setInterval(() => {
            console.log('setInterval...', countRef.current)
            // setCount(count + 1)
            setCount(++countRef.current)
        }, 1000)

        // 清除定时任务
        return () => clearTimeout(timer)
    }, []) // 依赖为 []

    // 依赖为 [] 时： re-render 不会重新执行 effect 函数
    // 没有依赖：re-render 会重新执行 effect 函数

    return <div>count: {count}</div>
}

export default UseEffectChangeState
```



### 几个面试题

#### 为什么会有React Hooks，它解决了哪些问题

- 完善函数组件的能力，函数组件更适合React组件
- 组件逻辑复用，Hooks表现更好，使用Hooks，相同逻辑可分割到一个一个的useEffect中，而不是像class组件一样，分布在各个生命周期中
- class复杂组件正在变得费解，不易拆解，不易测试，逻辑混乱

**class组件的问题**

- 大型组件很难拆分和重构，很难测试（即class不易拆分）
- 相同业务逻辑，分散到各个方法中，逻辑混乱
- 复用逻辑变得复杂，如Mixins，HOC，Render Prop

所以函数组件更适合React组件，但需要Hooks增强功能



#### React Hooks 如何模拟组件生命周期

- 模拟 componentDidMount - useEffect 依赖 []

- 模拟 componentDidUpdate - useEffect 无依赖， 或者依赖 [a, b]

- 模拟 componentWillUnMount - useEffect 中返回一个函数

  - useEffect依赖[]，组件销毁时执行fn，等于WillUnMounted

  - useEffect无依赖或依赖[a, b]，组件更新时执行fn

  - 即，下一次执行useEffect之前，就会执行fn，无论更新或卸载

    

#### 如何自定义 Hook



#### React Hooks 性能优化

- useMemo缓存数据，useCallback缓存函数

- 相当于class组件的SCU和PureComponent



#### 使用 React Hooks 遇到哪些坑

- useState初始化值，只有第一次有效

- useEffect内部不能修改state

- useEffect可能出现死循环

  

#### Hooks 相比 HOC 和 Render Prop 有哪些优点

- 完全符合Hooks原有规则，没有其他要求，易理解记忆
- 变量作用域明确
- 不会产生组件嵌套





## webpack 和 babel

[webpack概念与基本配置](https://blog.csdn.net/Roselane_Begger/article/details/98635216?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162244124816780274149586%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162244124816780274149586&biz_id=0&spm=1018.2226.3001.4450)

### 基本配置

- 拆分配置和merge

- 启动本地服务

  ```js
      devServer: {
          port: 8080,
          progress: true,  // 显示打包的进度条
          contentBase: distPath,  // 根目录
          open: true,  // 自动打开浏览器
          compress: true,  // 启动 gzip 压缩
  
          // 设置代理
          proxy: {
              // 将本地 /api/xxx 代理到 localhost:3000/api/xxx
              '/api': 'http://localhost:3000',
  
              // 将本地 /api2/xxx 代理到 localhost:3000/xxx
              '/api2': {
                  target: 'http://localhost:3000',
                  pathRewrite: {
                      '/api2': ''
                  }
              }
          }
      }
  ```

- 处理ES6

- 处理样式
  - loader执行顺序：从后往前
  - postcss-loader：浏览器兼容css
  
- 处理图片

  - 生产模式

    ```js
    module: {
        rules: [
            // 图片 - 考虑 base64 编码的情况
            {
                test: /\.(png|jpg|jpeg|gif)$/,
                use: {
                    loader: 'url-loader',
                    options: {
                        name:'[name]_[hash].[ext]',
                        // 小于 5kb 的图片用 base64 格式产出
                        // 否则，依然延用 file-loader 的形式，产出 url 格式
                        limit: 5 * 1024,
                        outputPath:'image/'		//打包图片的位置
                        
                        // 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）
                        // publicPath: 'http://cdn.abc.com'
                    }
                }
            },
        ]
    },
    ```

  - 开发模式

    ```js
    module: {
        rules: [
            // 直接引入图片 url
            {
                test: /\.(png|jpg|jpeg|gif)$/,	//打包以png|jpg|jpeg|gif结尾的所有图片文件
                use:{
                    loader:'file-loader',
                    options: {
                        name:'[name]_[hash].[ext]',//保持原图片的名字+hash值和后缀,主要单引号
                        outputPath:'image/'//打包图片的位置
                    }
                }
            }
        ]
    },
    ```

- （模块化）

### 高级配置

#### 多入口

```js
    entry: {
        index: path.join(srcPath, 'index.js'),
        other: path.join(srcPath, 'other.js')
    },
	output: {
        // filename: 'bundle.[contentHash:8].js',  // 打包代码时，加上 hash 戳
        filename: '[name].[contentHash:8].js', // name 即多入口时 entry 的 key
        path: distPath,
        // publicPath: 'http://cdn.abc.com'  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到
    },
	    plugins: [
        // new HtmlWebpackPlugin({
        //     template: path.join(srcPath, 'index.html'),
        //     filename: 'index.html'
        // })

        // 多入口 - 生成 index.html
        new HtmlWebpackPlugin({
            template: path.join(srcPath, 'index.html'),
            filename: 'index.html',
            // chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用
            chunks: ['index', 'vendor', 'common']  // 要考虑代码分割
        }),
        // 多入口 - 生成 other.html
        new HtmlWebpackPlugin({
            template: path.join(srcPath, 'other.html'),
            filename: 'other.html',
            chunks: ['other']  // 只引用 other.js
        })
    ]
```



#### 抽离压缩CSS文件

```js
    module: {
        rules: [
            // 抽离 css
            {
                test: /\.css$/,
                loader: [
                    MiniCssExtractPlugin.loader,  // 注意，这里不再用 style-loader
                    'css-loader',
                    'postcss-loader'
                ]
            },
            // 抽离 less --> css
            {
                test: /\.less$/,
                loader: [
                    MiniCssExtractPlugin.loader,  // 注意，这里不再用 style-loader
                    'css-loader',
                    'less-loader',
                    'postcss-loader'
                ]
            }
        ]
    },
    plugins: [
        new CleanWebpackPlugin(), // 会默认清空 output.path 文件夹
        new webpack.DefinePlugin({
            // window.ENV = 'production'
            ENV: JSON.stringify('production')
        }),

        // 抽离 css 文件
        new MiniCssExtractPlugin({
            filename: 'css/main.[contentHash:8].css'
        })
    ],

    optimization: {
        // 压缩 css
        minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})],
    }

```

#### 抽离公共代码

内置的代码切分的规则：

- 新 bundle 被两个及以上模块引用，或者来自 node_modules
- 新 bundle 大于 30kb （压缩之前）
- 异步加载并发加载的 bundle 数不能大于 5 个
- 初始加载的 bundle 数不能大于 3 个

简单的说，Webpack 会把代码中的公共模块自动抽出来，变成一个包，前提是这个包大于 30kb，不然 Webpack 是不会抽出公共代码的，因为增加一次请求的成本是不能忽视的。

```js
    optimization: {
        // 分割代码块
        splitChunks: {
            chunks: 'all',
            /**
             * initial 入口 chunk，对于异步导入的文件不处理
                async 异步 chunk，只对异步导入的文件处理
                all 全部 chunk
             */

            // 缓存分组
            cacheGroups: {
                // 第三方模块
                vendor: {
                    name: 'vendor', // chunk 名称
                    priority: 1, // 权限更高，优先抽离，重要！！！
                    test: /node_modules/,
                    minSize: 0,  // 大小限制
                    minChunks: 1  // 最少复用过几次
                },

                // 公共的模块
                common: {
                    name: 'common', // chunk 名称
                    priority: 0, // 优先级
                    minSize: 0,  // 公共模块的大小限制
                    minChunks: 2  // 公共模块最少复用过几次
                }
            }
        }
    }
```

#### 懒加载

在一个js中异步加载的js，构建打包后生成另外的js

```js
// 引用动态数据 - 懒加载
setTimeout(() => {
    // 回顾vue react异步组件
    // 定义一个chunk
    import('./dynamic-data.js').then(res => {
        console.log(res.default.message);   // 注意这里的default
    })
}, 1500)
```

#### 处理JSX

配置.babellrc，babel解析

```
{
    "presets": ["@babel/preset-react"],
    "plugins": []
}
```

#### 处理Vue

```js
rules: [
    {
        test: /\.vue$/,
        loader: ['vue-loader'],
        include: srcPath
    },
]
```

#### sourceMap

[当面试官问Webpack的时候他想知道什么](https://juejin.cn/post/6943468761575849992)

`sourceMap`是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中`debug`问题会带来非常糟糕的体验，`sourceMap`可以帮助我们快速定位到源代码的位置，提高我们的开发效率。`sourceMap`其实并不是`Webpack`特有的功能，而是`Webpack`支持`sourceMap`，像`JQuery`也支持`souceMap`。

既然是一种源码的映射，那必然就需要有一份映射的文件，来标记混淆代码里对应的源码的位置，通常这份映射文件以`.map`结尾，里边的数据结构大概长这样：

```js
{
  "version" : 3,                          // Source Map版本
  "file": "out.js",                       // 输出文件（可选）
  "sourceRoot": "",                       // 源文件根目录（可选）
  "sources": ["foo.js", "bar.js"],        // 源文件列表
  "sourcesContent": [null, null],         // 源内容列表（可选，和源文件列表顺序一致）
  "names": ["src", "maps", "are", "fun"], // mappings使用的符号名称列表
  "mappings": "A,AAAB;;ABCDE;"            // 带有编码映射数据的字符串
}
```

其中`mappings`数据有如下规则：

- 生成文件中的一行的每个组用“;”分隔；
- 每一段用“,”分隔；
- 每个段由1、4或5个可变长度字段组成；

有了这份映射文件，我们只需要在我们的压缩代码的最末端加上这句注释，即可让sourceMap生效：

```js
//# sourceURL=/path/to/file.js.map
```

有了这段注释后，浏览器就会通过`sourceURL`去获取这份映射文件，通过解释器解析后，实现源码和混淆代码之间的映射。因此sourceMap其实也是一项需要浏览器支持的技术。

如果我们仔细查看webpack打包出来的bundle文件，就可以发现在默认的`development`开发模式下，每个`_webpack_modules__`文件模块的代码最末端，都会加上`//# sourceURL=webpack://file-path?`，从而实现对sourceMap的支持。

#### module chunk bundle的区别

- module：各个源码文件，webpack中一切皆模块
- chunk：多模块合并成的，如entry import() splitChunk
- bundle：最终的输出文件



### 性能优化

#### 构建速度

- 优化babel-loader

  ```js
  {
      test: /\.js$/,
    	loader: ['babel-loader?cacheDirectory'],	// 开启缓存
      include: path.resolve(__dirname, 'src'),	// 明确范围
      // 排除范围，include和exclude两者选一个即可
      // exclude: path.resolve(__dirname, 'node_modules')
  }
  ```

- IgnorePlugin 避免引用无用模块（直接不引入，代码中没有）

  以moment.js为例，忽略语言包

  ```js
  // 忽略 moment 下的 /locale 目录
  new webpack.IgnorePlugin(/\.\/locale/, /moment/),
  ```

- noParse避免重复打包（引入，但不打包）

  ```js
  module.exports = {
      module: {
          // 独完整的 react.min.js 文件就没有采用模块化
          // 忽略对 react.min.js 文件的递归解析处理
          noParse: [/react\.min\.js$/]
      }
  }
  ```

- happyPack 多进程打包（提高构建速度，特别是多核CPU）

  ```js
      module: {
          rules: [
              // js
              {
                  test: /\.js$/,
                  // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例
                  use: ['happypack/loader?id=babel'],
                  include: srcPath,
                  // exclude: /node_modules/
              }
          ]
      },
      plugins: [
          // happyPack 开启多进程打包
          new HappyPack({
              // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件
              id: 'babel',
              // 如何处理 .js 文件，用法和 Loader 配置中一样
              loaders: ['babel-loader?cacheDirectory']
          }),
      ]
  ```

- ParallelUglifyPlugin 多进程压缩js

  - 项目较大，打包较慢，开启多进程能提高速度
  - 项目较小，打包很快，开启多进程会减低速度（进程开销）
  - 按需使用

  ```js
  plugins: [
      // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码
      new ParallelUglifyPlugin({
          // 传递给 UglifyJS 的参数
          // （还是使用 UglifyJS 压缩，只不过帮助开启了多进程）
          uglifyJS: {
              output: {
                  beautify: false, // 最紧凑的输出
                  comments: false, // 删除所有的注释
              },
              compress: {
                  // 删除所有的 `console` 语句，可以兼容ie浏览器
                  drop_console: true,
                  // 内嵌定义了但是只用到一次的变量
                  collapse_vars: true,
                  // 提取出出现多次但是没有定义成变量去引用的静态值
                  reduce_vars: true,
              }
          }
      })
  ]
  ```

- 自动刷新

  ```js
      watch: true, // 开启监听，默认为 false
      watchOptions: {
          ignored: /node_modules/, // 忽略哪些
          // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高
          // 默认为 300ms
          aggregateTimeout: 300,
          // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的
          // 默认每隔1000毫秒询问一次
          poll: 1000
      }
  ```

- 热更新（HMR）

  - 自动刷新：整个网页全部刷新，速度较慢，状态会丢失
  - 热更新：新代码生效，网页不刷新，状态不丢失，但是成本更高

  ```js
      const HotModuleReplacementPlugin = require('webpack/lib/HotModuleReplacementPlugin');
  
      entry: {
          // index: path.join(srcPath, 'index.js'),
          index: [
              'webpack-dev-server/client?http://localhost:8080/',
              'webpack/hot/dev-server',
              path.join(srcPath, 'index.js')
          ],
          other: path.join(srcPath, 'other.js')
      },
      plugins: [
          new webpack.DefinePlugin({
              // window.ENV = 'production'
              ENV: JSON.stringify('development')
          }),
          new HotModuleReplacementPlugin()
      ],
  	devserver: {
          hot: true
      }
  ```

  ```js
  // index.js
  // 增加，开启热更新之后的代码逻辑
  if (module.hot) {
      module.hot.accept(['./math'], () => {
          const sumRes = sum(10, 20)
          console.log('sumRes in hot', sumRes)
      })
  }
  ```

  

- DLLPlugin 动态链接库插件

  将依赖单独打包，这样以后每次只构建业务代码
  
  DllPlugin 配置流程大致分为三步：

  1）创建 dll.config.js 配置文件
  
  ```js
  import { DllPlugin } from "webpack";
  
  export default {
      // 需要抽离的依赖
      entry: {
          vendor: ["vue", "vue-router", "axios", "echarts"]
      },
      mode: "production",
      optimization: {
          splitChunks: {
              cacheGroups: {
                  vendor: {
                      chunks: "all",
                      name: "vendor",
                      test: /node_modules/
                  }
              }
          }
      },
      output: {
          filename: "[name].dll.js", // 输出路径和文件名称
          library: "[name]", // 全局变量名称：其他模块会从此变量上获取里面模块
          path: AbsPath("dist/static") // 输出目录路径
      },
      plugins: [
          new DllPlugin({
              name: "[name]", // 全局变量名称：减小搜索范围，与output.library结合使用
              path: AbsPath("dist/static/[name]-manifest.json") // 输出目录路径
          })
      ]
  };
  ```
  
  2）package.json 配置脚本
  
  ```js
  "build:dll": "webpack --config ./dll.config.js",
  ```
  
  3）使用 `DllReferencePlugin` 将打包生成的dll文件，引用到需要的预编译的依赖上来，并通过 `html-webpack-tags-plugin` 在打包时自动插入dll文件
  
  vue.config.js 配置如下:
  
  ```js
  import { DllReferencePlugin } from "webpack";
  import HtmlTagsPlugin from "html-webpack-tags-plugin";
  
  export default {
    configureWebpack: {
      plugins: [
        new DllReferencePlugin({
          manifest: AbsPath("dist/static/vendor-manifest.json") // manifest文件路径
        }),
        new HtmlTagsPlugin({
          append: false, // 在生成资源后插入
          publicPath: "/", // 使用公共路径
          tags: ["static/vendor.dll.js"] // 资源路径
        })
      ]
    }
  };
  ```
  
  

总结

用于生产环境

- 优化babel-loader
- IgnorePlugin
- noParse
- happyPack
- ParallelUglifyPlugin

开发环境

- 自动刷新
- 热更新
- DLLPlugin

#### 产出代码

- 小图片base64编码

- bundle加hash

- 懒加载

- 提取公共代码

- IgnorePlugin

- 使用CDN加速

  1、publicPath配置cdn网址 `publicPath: 'http://cdn.abc.com'  // 修改所有静态文件 url 的前缀（如 cdn 域名）`

  2、将打包资源CSS、JS等上传到cdn

- 使用production环境

  - 自动开启代码压缩
  - Vue React等会自动删掉调试代码（如开发环境的warning）
  - **tree-shaking（清除无用未使用代码）**

- scope hosting 作用域提升

  - 代码体积更小
  - 创建函数作用域更少
  - 代码可读性更好



**ES6 Module和Common.js 的区别**

- ES6 Module静态引入，编译时引入
- commonjs动态引入，执行时引入
- 只有在ES6 Module才能静态分析，实现tree-shaking

```js
// ES6 Module.js
import apiList from '../config/api.js'
if (isDev) {
    // 编译时报错，只能静态引入
    import apiList from '../config/api_dev.js'
}

// common.js
let apiList = require('../config/api.js')
if (isDev) {
    // 可以动态引入，执行时引入
    apiList = require('../config/api_dev.js')
}
```



### babel

#### 环境搭建&基本配置

#### babel-polyfill

- 什么是polyfill ：补丁 兼容语法
- corejs和regenerator
- babel-polyfill是两者的集合
- babel7.4之后弃用babel-polyfill
- 推荐直接使用corejs和regenerator
- 问题：会污染全局环境

##### babel-polyfill 配置按需引入

```
// .babelrc
"presets": [
        [
            "@babel/preset-env",
            {
                "useBuiltIns": "usage",
                "corejs": 3
            }
        ]
    ]
```

#### babel-runtime

- 不会污染全局环境（会重新取变量名）

- 适用于开发第三方库



### :star:Webpack构建流程概述

1、读取`webpack`的配置参数；

2、启动`webpack`，创建`Compiler`对象并开始解析项目；

3、从入口文件（`entry`）开始解析，并且找到其导入的依赖模块（`module`），递归遍历分析，形成依赖关系树；

4、对不同文件类型的依赖模块文件使用对应的`Loader`进行编译，最终转为`Javascript`文件；

5、整个过程中`webpack`会通过发布订阅模式，向外抛出一些`hooks`，而`webpack`的插件（`plugin`）即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。



### 4、webpack打包过程

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始
3. 执行编译；确定入口：根据配置中的 entry 找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 API 改变 webpack

这个步骤中没有提到plugins，实际上，webpack在打包过程中会在不同阶段广播一些事件钩子，不同的plugins有自己作用的时间，当听到这些钩子时，将开始执行。



### 5、less在webpack中时如何被打包的

less-loader -> css-loader -> style-loader

- less-loader：用于将less翻译成浏览器可识别的css
- css-loader：处理 import / require（） @import / url 引入的内容
- style-loader：通过一个JS脚本创建一个style标签，里面包含一些样式



### Vite是什么

- 一个前端打包工具，Vue作者发起的项目
- 借助Vue的影响力，发展较快，和webpack竞争
- 优势：开发环境下无需打包，启动快
  - 因为开发环境使用ES6 Module，无须打包  `<script type="module">`
  - 生产环境使用rollup，并不会快很多



### webpack和vite的区别

[搞懂vite为什么比webpack快！运行原理、构建方式等有什么不同！](https://zhuanlan.zhihu.com/p/679561937)



### 面试真题演练

#### 前端为什么要进行打包构建

- 体积更小（tree-shaking、压缩、合并），加载更快
- 编译高级语言或语法（TS、ES5+、模块化、scss）
- 兼容性和错误提示（polyfill、postcss、eslint）
- 统一高效的开发环境
- 统一的构建流程和产出标准
- 集成公司构建规范（提测、上线等）

#### loader和plugin的区别

- loader模块转换器，如less => css

- plugin扩展插件，如HtmlWebpackPlugin

#### babel和webpack的区别

- babel：js语法编译工具，不关心模块化
- webpack：打包构建工具，十多个loader plugin的集合

#### 如何产出一个lib（第三方工具）

参考webpack.dll.js

```js
output: {
    // lib的文件名
    filename: 'lodash.js',
    // 输出lib到dist目录下
    path: distPath,
    // lib的全局变量名
    library: 'lodash'
}
```



## 项目设计

### 状态设计

- 用数据描述所有的内容
- 数据要结构化，易于程序操作（遍历、查找）
- 数据要可扩展，以便增加新的功能

### 组件设计

- 从功能上拆分层次
- 尽量让组件原子化
- 容器组件（只管理数据）&UI组件（只显示视图）



## 项目流程

- PM想在项目开发过程中增加需求，该怎么办
  - 不能拒绝，走需求变更流程即可
  - 如果公司有规定就按规定走，否则，发起项目组和leader的评审，重新评估排期
- 项目即将延期了，该怎么办
- 你将如何保证项目质量

### 项目角色

- PM产品经理
- UE视觉设计师
- FE前端开发
- RD后端开发
- CRD移动端开发
- QA测试人员

### 完整项目流程

- 需求分析（各个角色）
- 技术方案设计（FE RD CRD）
- 开发（FE）
- 联调（FE RD CRD）
- 测试（FE QA）
- 上线（FE）

















